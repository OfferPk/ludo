<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Ludo Game</title>
    <style>
        :root {
            /* Color palette */
            --red: #e74c3c;
            --green: #2ecc71;
            --blue: #3498db;
            --yellow: #f1c40f;
            --purple: #9b59b6;
            --orange: #e67e22;
            /* --teal: #1abc9c; --pink: #e91e63; */ /* Kept for reference */
            --gray: #ecf0f1;
            --dark-gray: #333;
            --light-gray: #f5f5f5;
            --board-bg: #fdfdfd;
            --safe-star-color: #ffd700;
            --dice-red: #e74c3c;
            --dice-white: #ffffff;
        }
        
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: var(--light-gray);
            min-height: 100vh;
            padding-bottom: 20px;
            color: var(--dark-gray);
        }
        
        header {
            width: 100%;
            background: linear-gradient(135deg, #6e48aa 0%, #9d50bb 100%);
            color: white;
            padding: 15px 0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            position: sticky;
            top: 0;
            z-index: 500;
        }
        
        h1 {
            margin: 0;
            font-size: 2.2rem;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
        }
        
        .back-button, .close-button {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px 15px;
            border-radius: 30px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .back-button {
            left: 20px;
        }
        .close-button {
            right: 20px;
        }
        .back-button:hover, .close-button:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-50%) scale(1.05);
        }
        
        /* Player selection screen */
        .player-selection {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--light-gray);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 100;
            overflow-y: auto;
            padding-top: 80px; /* Space for sticky header */
            box-sizing: border-box;
        }
        
        .player-selection-content {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
            max-width: 800px;
            width: 90%;
            margin: 20px auto;
            text-align: center;
        }
        
        .player-selection-content h2 {
            color: var(--dark-gray);
            font-size: 1.8rem;
            margin-bottom: 25px;
            position: relative;
            margin-top: 5px;
        }
        
        .player-selection-content h2::after {
            content: ""; display: block; width: 60px; height: 4px;
            background: linear-gradient(90deg, #6e48aa, #9d50bb);
            margin: 10px auto; border-radius: 2px;
        }

        .player-selection-content h3 {
            margin-top:25px; margin-bottom:10px;
            color: var(--dark-gray); font-size: 1.3rem;
        }
        
        .player-options {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px; margin-bottom: 30px;
        }
        
        .player-option {
            background: white; padding: 20px 15px; border-radius: 12px;
            text-align: center; cursor: pointer; transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1); border: 2px solid transparent;
            position: relative; overflow: hidden; flex-basis: calc(50% - 20px);
        }
         @media (min-width: 600px) {
             .player-option { flex-basis: calc(25% - 20px); } 
        }
        
        .player-option::before {
            content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 5px;
            background: var(--purple); transform: scaleX(0); transition: transform 0.3s;
        }
        
        .player-option:hover, .player-option.selected {
            transform: translateY(-5px); box-shadow: 0 8px 15px rgba(0,0,0,0.15);
            border-color: #6e48aa;
        }
        
        .player-option.selected::before { transform: scaleX(1); }
        
        .player-option h3 { font-size: 1.1rem; margin: 0 0 8px 0; color: #6e48aa; font-weight: 600; }
        .player-option p { color: #666; margin: 0; font-size: 0.9em; }
        
        /* Profile and betting sections */
        .profile-rewards-section, .betting-section {
            margin-bottom: 20px; padding: 20px; background: #f9f9f9;
            border-radius: 12px; border: 1px solid #eee; text-align: left;
        }
        
        .profile-rewards-section h3, .betting-section h3 {
            margin-top: 0; color: var(--dark-gray); font-size: 1.3rem;
            margin-bottom: 15px; display: flex; align-items: center; gap: 10px;
        }
        
        .profile-rewards-section h3::before { content: "üë§"; font-size: 1.2em; }
        .betting-section h3::before { content: "üí∞"; font-size: 1.2em; }

        
        .stats-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px; margin-bottom: 20px;
        }
        
        .stat-item {
            background: white; padding: 15px; border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05); font-size: 0.95em;
            display: flex; flex-direction: column; align-items: center;
        }
        .stat-item span { color: #555; }
        .stat-item strong { color: #6e48aa; font-size: 1.3em; margin-top: 5px; }
        
        #watchAdButton {
            background: linear-gradient(135deg, var(--green) 0%, #58d68d 100%);
            margin-top: 15px; width: 100%; padding: 12px; font-size: 1em;
            border: none; border-radius: 8px; color: white; font-weight: bold; cursor: pointer;
            transition: all 0.3s; box-shadow: 0 3px 8px rgba(0,0,0,0.1);
            display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        #watchAdButton:hover { transform: translateY(-2px); box-shadow: 0 5px 12px rgba(0,0,0,0.15); }
        #watchAdButton:disabled { background: #aaa; cursor: not-allowed; transform: none; box-shadow: none;}
        #watchAdButton::before { content: "‚ñ∂"; font-size: 1.1em; }
        #adRewardMessage { font-size: 0.85em; margin-top: 10px; color: #666; text-align: center; min-height:1.2em; }
        
        .bet-options { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; }
        .bet-option {
            padding: 10px 15px; background: white; border: 1px solid #ddd;
            border-radius: 25px; cursor: pointer; transition: all 0.2s;
            font-weight: bold; font-size: 0.9em; min-width: 70px;
            text-align: center; box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .bet-option:hover { background: #f0f0f0; }
        .bet-option.selected {
            background: #6e48aa; color: white; border-color: #6e48aa;
            box-shadow: 0 3px 8px rgba(110, 72, 170, 0.3);
        }
        #currentBetInfo { margin-top: 15px; display: flex; justify-content: space-between; font-size: 0.9em; padding: 0 5px; }

        #startGameButton {
            margin-top: 30px; background: linear-gradient(135deg, var(--orange) 0%, #f39c12 100%);
            width: 100%; font-size: 1.2em; padding: 15px; border: none;
            color: white; border-radius: 10px; cursor: pointer; transition: all 0.3s;
            font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            display: flex; align-items: center; justify-content: center; gap: 10px;
        }
        #startGameButton:hover { transform: translateY(-3px); box-shadow: 0 6px 15px rgba(0,0,0,0.15); opacity: 0.95; }
        #startGameButton::before { content: "üé≤"; font-size: 1.2em; }
        
        /* Game container */
        .game-container {
            position: relative; margin: 20px; background: white; border-radius: 15px;
            padding: 20px; box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            display: none; flex-direction: column; align-items: center;
            max-width: 800px; width: 95%;
        }
        
        #ludoCanvasContainer { /* Added for animation positioning */
            position: relative; 
            width: 100%; max-width: 600px;
            margin: 0 auto; /* Center the canvas and its container */
        }
        canvas {
            background: var(--board-bg); border: 3px solid var(--dark-gray);
            border-radius: 12px; box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);
            width: 100%; /* Fill its container */
            height: auto; aspect-ratio: 1/1; display:block;
        }
        
        .game-info {
            margin-top: 20px; padding: 20px; background: white; border-radius: 12px;
            box-shadow: 0 3px 12px rgba(0,0,0,0.1); width: 100%; max-width: 600px;
            text-align: center; border: 1px solid #eee;
        }
        .game-info-pot { font-weight: bold; margin-bottom: 10px; color: var(--dark-gray); }

        .current-player {
            font-size: 1.3rem; font-weight: bold; margin-bottom: 10px;
            display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        .current-player::before {
            content: ""; display: inline-block; width: 15px; height: 15px;
            border-radius: 50%; background: currentColor; border: 1px solid rgba(0,0,0,0.2);
        }
        
        .dice-value { font-size: 1.5rem; font-weight: bold; color: var(--dice-red); margin-bottom: 10px; }
        .game-message {
            margin-top: 15px; padding: 12px; border-radius: 8px; background: #f8f9fa;
            font-weight: 500; min-height: 20px; border-left: 4px solid #6e48aa;
        }
        
        .controls {
            margin-top: 25px; display: flex; flex-wrap: wrap; gap: 20px;
            justify-content: center; align-items: center; width: 100%; max-width: 600px;
        }
        
        .dice-container { display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .dice {
            width: 80px; height: 80px; background: linear-gradient(135deg, var(--dice-red) 0%, #c0392b 100%);
            border-radius: 15px; color: var(--dice-white); font-size: 48px;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2); transition: all 0.3s ease; user-select: none;
            position: relative; overflow: hidden;
        }
        .dice:hover { transform: scale(1.05); box-shadow: 0 8px 16px rgba(0, 0, 0, 0.25); }
        .dice.animate { animation: diceRollEnhanced 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55); }
        
        @keyframes diceRollEnhanced { /* More dynamic roll */
            0% { transform: rotate3d(1, 1, 0, 0deg) scale(1); }
            30% { transform: rotate3d(1, 1, 0, 360deg) scale(1.3); }
            60% { transform: rotate3d(1, 1, 0, 720deg) scale(0.8); }
            100% { transform: rotate3d(1, 1, 0, 1080deg) scale(1); }
        }
        
        .dice::after {
            content: ""; position: absolute; top: 5px; left: 5px; right: 5px; bottom: 5px;
            border: 2px solid rgba(255,255,255,0.3); border-radius: 10px; pointer-events: none;
        }
        
        .countdown-container { display: flex; flex-direction: column; align-items: center; gap: 8px; min-width: 150px; }
        .countdown-label { font-size: 0.9em; color: #666; font-weight: 500; }
        .countdown {
            width: 100%; height: 15px; background: #eee; position: relative;
            border-radius: 10px; overflow: hidden; box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        .countdown-bar {
            height: 100%; background: linear-gradient(90deg, #ff5f6d, #ffc371);
            width: 100%; transition: width 0.5s linear; border-radius: 10px;
        }
        
        .token-balances {
            display: flex; flex-wrap: wrap; gap: 12px; margin-top: 20px;
            justify-content: center; max-width: 600px; width: 100%;
        }
        .token-balance {
            font-size: 15px; font-weight: bold; padding: 8px 16px; border-radius: 20px;
            color: white; min-width: 80px; text-align: center;
            box-shadow: 0 3px 8px rgba(0,0,0,0.1); display: flex; align-items: center; gap: 8px;
        }
        .token-balance::before { /* Little color dot */
            content: ""; display: inline-block; width: 12px; height: 12px;
            border-radius: 50%; background: currentColor; opacity: 0.8;
            border: 1px solid rgba(0,0,0,0.2);
        }
        
        .custom-turn-order {
            display: flex; flex-wrap: wrap; gap: 12px; margin-top: 20px;
            justify-content: center; align-items: center; max-width: 600px; width: 100%;
            padding: 15px; background: #f9f9f9; border-radius: 10px;
        }
        .custom-turn-order label { font-weight: bold; color: #555; margin-right: 5px; }
        .custom-turn-order input {
            width: 50px; padding: 8px; border: 2px solid #ddd; border-radius: 8px;
            text-align: center; font-weight: bold; transition: all 0.2s;
        }
        .custom-turn-order input:focus {
            outline: none; border-color: #6e48aa; box-shadow: 0 0 0 2px rgba(110, 72, 170, 0.2);
        }
        
        .settings-panel {
            margin-top: 25px; background: #fff; padding: 20px; border-radius: 15px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.1); width: 100%; max-width: 600px; border: 1px solid #eee;
        }
        .settings-panel h3 {
            margin-top: 0; margin-bottom: 15px; color: #6e48aa; font-size: 1.2em;
            display: flex; align-items: center; gap: 10px;
        }
        .settings-panel h3::before { content: "‚öôÔ∏è"; font-size: 1.1em; }
        .setting-row {
            display: flex; align-items: center; margin: 12px 0; padding: 10px;
            background: #f9f9f9; border-radius: 8px; transition: all 0.2s;
        }
        .setting-row:hover { background: #f0f0f0; }
        .setting-row input[type="checkbox"] { width: 20px; height: 20px; accent-color: #6e48aa; cursor: pointer; }
        .setting-row label { margin-left: 12px; font-weight: 500; color: var(--dark-gray); font-size: 0.95em; cursor: pointer; flex-grow: 1;}
        
        .settings-panel button { /* Reset game button */
            margin-top: 20px; width: 100%; padding: 12px; font-size: 1em;
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white; border: none; border-radius: 8px; cursor: pointer;
            transition: all 0.3s; font-weight: bold; box-shadow: 0 3px 8px rgba(0,0,0,0.1);
        }
        .settings-panel button:hover { transform: translateY(-2px); box-shadow: 0 5px 12px rgba(0,0,0,0.15); }
        
        /* Popup dialogs */
        .win-message, .exit-confirmation, .forced-close-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); /* Slightly darker overlay */
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1000; color: white; text-align: center; padding: 20px; box-sizing: border-box;
            animation: fadeIn 0.3s ease-out;
        }
        
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        
        .modal-content { /* Common styling for popup content box */
            background: white; padding: 30px 40px; border-radius: 15px;
            text-align: center; max-width: 480px; width: 90%;
            color: var(--dark-gray); box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            animation: scaleInModal 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes scaleInModal { from { transform: scale(0.8); opacity: 0;} to {transform: scale(1); opacity: 1;}}

        .win-message h2, .forced-close-overlay h2 {
            font-size: 2.5rem; margin-bottom: 15px;
            text-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .win-message h2 { color: gold; }
        .forced-close-overlay h2 { color: var(--red); }


        .win-message p, .forced-close-overlay p { font-size: 1.2rem; margin-bottom: 20px; line-height: 1.5; color: #eee;}
        .win-message .modal-content p, .forced-close-overlay .modal-content p { color: var(--dark-gray); } /* For text inside modal box */
        
        .win-message #winStats { margin-bottom: 25px; font-size: 1.1em; background: #f0f0f0; padding:10px; border-radius:8px;}
        .win-message #winStats span { display:block; margin: 5px 0; }

        .win-message button, .forced-close-overlay button {
            margin-top: 10px; font-size: 1.1rem; padding: 12px 25px;
            border: none; border-radius: 8px; cursor: pointer; transition: all 0.3s;
            font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }
        .win-message button:first-of-type { background: linear-gradient(135deg, #6e48aa 0%, #9d50bb 100%); color: white; }
        .win-message button:last-of-type { background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; }

        .forced-close-overlay button { background: linear-gradient(135deg, #6e48aa 0%, #9d50bb 100%); color: white;}

        .win-message button:hover, .forced-close-overlay button:hover { transform: translateY(-3px); box-shadow: 0 6px 15px rgba(0,0,0,0.2); }
        
        /* .exit-dialog structure now directly styled within .exit-confirmation .modal-content */
        .exit-confirmation .modal-content h3 { margin-top: 0; font-size: 1.5rem; color: #6e48aa; }
        .exit-buttons { display: flex; justify-content: center; gap: 15px; margin-top: 25px; }
        .exit-buttons button {
            min-width: 120px; padding: 12px 20px; font-size: 1em; border-radius: 8px;
            border:none; color:white; font-weight:bold; cursor:pointer; transition: all 0.3s;
        }
        .exit-buttons button:hover { transform: translateY(-2px); }
        #confirmExitButton { background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); }
        .exit-buttons button:last-child { background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%); }
        
        .forced-close-overlay .timer { font-size: 1.5rem; color: var(--yellow); font-weight: bold; margin: 10px 0; }
        
        /* Token Highlight on Canvas (managed by JS redraw) */
        /* Animation for temporary visual token on move (CSS based) */
        .animated-token-visual {
            position: absolute;
            background-color: red; /* Will be set by JS */
            border-radius: 50%; /* Or draw cone with pseudo elements if needed */
            transition: transform 0.5s ease-in-out;
            z-index: 20; /* Above canvas, below UI popups */
            /* Width and Height set by JS */
        }
        
        /* Confetti - general styles */
        .confetti-container { position: fixed; top:0; left:0; width:100%; height:100%; pointer-events: none; z-index: 2000;}
        .confetti {
            position: absolute; /* Relative to .confetti-container */
            width: 8px; height: 15px; /* Rectangular confetti */
            opacity: 0.8;
            animation: fall 4s linear infinite; /* Loop is ok here, individual particles will be removed */
        }
        @keyframes fall {
            to { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

    </style>
</head>
<body>
    <header>
        <button class="back-button" id="backButton" style="display: none;">‚Üê Home</button>
        <h1>Ultimate Ludo Game</h1>
        <button class="close-button" id="closeButton" style="display: none;">‚úï Quit</button>
    </header>

    <div class="player-selection" id="playerSelectionScreen">
        <div class="player-selection-content">
            <h2>Game Dashboard</h2>
            <div class="profile-rewards-section">
                <h3>Your Player Profile</h3>
                <div class="stats-grid">
                    <div class="stat-item"><span>Coins</span><strong id="playerCoins">0</strong></div>
                    <div class="stat-item"><span>Wins</span><strong id="playerWins">0</strong></div>
                    <div class="stat-item"><span>Played</span><strong id="playerGamesPlayed">0</strong></div>
                    <div class="stat-item"><span>Win Rate</span><strong id="playerWinRate">0%</strong></div>
                </div>
                <button id="watchAdButton" onclick="watchAdForCoins()">Watch Ad for Coins (+500)</button>
                <p id="adRewardMessage"></p>
            </div>
            <div class="betting-section">
                <h3>Place Your Bet</h3>
                <p style="color: #666; font-size: 0.9em; margin-bottom: 15px;">Each player contributes this amount to the pot.</p>
                <div class="bet-options" id="betOptionsContainer"></div>
                <div id="currentBetInfo"><span id="currentBetDisplay">Current Bet: 0</span> <span id="potentialWinDisplay">Potential Win: 0</span></div>
            </div>
            <h3>Game Setup</h3>
            <div class="player-options" id="playerOptionsContainer">
                <div class="player-option" data-value="2"><h3>2 Players</h3><p>1v1 Classic</p></div>
                <div class="player-option" data-value="3"><h3>3 Players</h3><p>Triple Threat*</p></div>
                <div class="player-option" data-value="4"><h3>4 Players</h3><p>Full Board</p></div>
                <div class="player-option" data-value="6"><h3>6 Players</h3><p>Extended Chaos**</p></div>
            </div>
             <p style="font-size: 0.75em; color: #777; margin-top:5px; text-align:left; padding-left:10px;">
                *3 Player uses a 4-arm board (one arm inactive).<br>
                **6 Player uses a modified 4-arm board layout.
            </p>
             <div style="margin-top: 20px; text-align: left;">
                <label for="gameDifficulty" style="display: block; margin-bottom: 8px; font-weight: bold;">Game Difficulty:</label>
                <select id="gameDifficulty" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ddd; background:white;">
                    <option value="easy">Easy</option>
                    <option value="medium" selected>Medium</option>
                    <option value="hard">Hard</option>
                </select>
            </div>
            <button id="startGameButton" onclick="validateAndStartGame()">Start Game</button>
        </div>
    </div>

    <div class="game-container" id="gameContainer">
         <div id="ludoCanvasContainer"> <!-- Added container -->
            <canvas id="ludoCanvas" width="600" height="600"></canvas>
        </div>
        <div class="game-info">
            <div class="game-info-pot">Game Pot: <span id="gamePotDisplay">0</span> coins</div>
            <div class="current-player" id="currentPlayer">Current Player: Red</div>
            <div class="dice-value" id="diceValue">Dice: -</div>
            <div class="game-message" id="gameMessage">Welcome! Click dice or token.</div>
        </div>
        <div class="controls">
            <div class="dice-container">
                <div class="dice" id="dice">üé≤</div>
            </div>
            <div class="countdown-container">
                 <div class="countdown-label">Auto Turn</div>
                <div class="countdown" id="countdown"><div class="countdown-bar" id="countdownBar"></div></div>
            </div>
        </div>
        <div class="token-balances" id="tokenBalances"></div>
        <div class="custom-turn-order" id="customTurnOrderContainer">
            <label>Turn Order:</label> <button onclick="updateTurnOrder()">Update</button>
        </div>
        <div class="settings-panel">
            <h3>Game Settings</h3>
            <div class="setting-row"><input type="checkbox" id="autoMode" checked><label for="autoMode">AI for Other Players</label></div>
            <div class="setting-row"><input type="checkbox" id="autoRoll" checked><label for="autoRoll">Auto-Roll for AI</label></div>
            <div class="setting-row"><input type="checkbox" id="smartCapture" checked><label for="smartCapture">Smart Capture (AI)</label></div>
            <div class="setting-row"><input type="checkbox" id="safeMove" checked><label for="safeMove">Safe Moves (AI)</label></div>
            <div class="setting-row"><input type="checkbox" id="animations" checked><label for="animations">Game Animations</label></div>
            <div class="setting-row"><input type="checkbox" id="aiVsAi"><label for="aiVsAi">AI vs AI Simulation</label></div>
            <div class="setting-row"><input type="checkbox" id="soundEffects" checked><label for="soundEffects">Sound Effects</label></div>
            <button onclick="resetGameConfirm()">Reset Current Game</button>
        </div>
    </div>
    
    <div class="confetti-container" id="confettiContainer"></div>

    <div class="win-message" id="winMessage"> 
        <div class="modal-content"> 
            <h2 id="winnerText">Player Wins!</h2>
            <p id="winDetails">Congratulations on your victory!</p>
            <div id="winStats"></div>
            <button onclick="playAgain()">Play Again</button>
            <button onclick="returnToHome()" style="margin-top:15px; background: gray;">Back to Home</button>
        </div>
    </div>
    <div class="exit-confirmation" id="exitConfirmation"> 
        <div class="modal-content"> 
            <h3 id="exitDialogTitle">Exit Game</h3>
            <p id="exitDialogMessage">Are you sure?</p>
            <div class="exit-buttons">
                <button id="confirmExitButton" onclick="confirmQuitGame()">Yes</button>
                <button onclick="cancelExit()">No</button>
            </div>
        </div>
    </div>
    <div class="forced-close-overlay" id="forcedCloseOverlay">
         <div class="modal-content"> 
            <h2 id="forcedCloseTitle">Game Over</h2>
            <p id="forcedCloseMessage">Player left the game.</p>
            <p>Returning to home in <span id="forcedCloseTimer" class="timer">5</span>s</p>
            <button onclick="returnToHome()" style="margin-top:15px;">OK</button>
        </div>
    </div>

    <audio id="diceSound" src="https://assets.mixkit.co/sfx/preview/mixkit-plastic-dice-roll-1494.mp3" preload="auto"></audio>
    <audio id="moveSound" src="https://assets.mixkit.co/sfx/preview/mixkit-unlock-game-notification-253.mp3" preload="auto"></audio>
    <audio id="captureSound" src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-explosion-2759.mp3" preload="auto"></audio>
    <audio id="winSound" src="https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3" preload="auto"></audio>
    <audio id="errorSound" src="https://assets.mixkit.co/sfx/preview/mixkit-game-show-wrong-answer-buzz-950.mp3" preload="auto"></audio>
    <audio id="coinSound" src="https://assets.mixkit.co/sfx/preview/mixkit-game-success-alert-2039.mp3" preload="auto"></audio>
    <audio id="backgroundMusic" loop src="https://assets.mixkit.co/music/preview/mixkit-game-show-suspense-waiting-668.mp3" preload="auto"></audio>

    <script>
        // --- Constants for LocalStorage & Game Logic ---
        const LS_PREFIX = 'ultimateLudoV1_'; // Prefix for all localStorage keys
        const LS_KEYS = {
            COINS: LS_PREFIX + 'coins', WINS: LS_PREFIX + 'wins', GAMES_PLAYED: LS_PREFIX + 'gamesPlayed',
            BONUS_RECEIVED: LS_PREFIX + 'bonusReceived', AD_DATE: LS_PREFIX + 'adDate', AD_COINS: LS_PREFIX + 'adCoinsToday'
        };
        const DAILY_AD_COIN_LIMIT = 5000, AD_REWARD_AMOUNT = 500, JOINING_BONUS_AMOUNT = 5000;
        const BET_AMOUNTS = [500, 1000, 10000, 50000, 100000, 500000, 1000000, 5000000, 10000000];
        
        const canvasEl = document.getElementById('ludoCanvas');
        const canvasContainer = document.getElementById('ludoCanvasContainer');
        const ctx = canvasEl.getContext('2d');
        
        const TOKENS_PER_PLAYER = 4, HOME_STRETCH_LENGTH = 6;
        let GRID_SIZE, CELL_SIZE, TOKEN_RADIUS, MAIN_TRACK_LENGTH;
        let ACTIVE_PLAYER_GEOMETRY_CONFIG = [], ACTIVE_MAIN_TRACK_COORDS = [], ACTIVE_SAFE_SQUARE_INDICES = [];
        const DEFAULT_MAIN_TRACK_COORDS_4P = [[1,6],[2,6],[3,6],[4,6],[5,6],[6,5],[6,4],[6,3],[6,2],[6,1],[6,0],[7,0],[8,0],[8,1],[8,2],[8,3],[8,4],[8,5],[9,6],[10,6],[11,6],[12,6],[13,6],[14,6],[14,7],[14,8],[13,8],[12,8],[11,8],[10,8],[9,8],[8,9],[8,10],[8,11],[8,12],[8,13],[8,14],[7,14],[6,14],[6,13],[6,12],[6,11],[6,10],[6,9],[5,8],[4,8],[3,8],[2,8],[1,8],[0,8],[0,7],[0,6]];
        const DEFAULT_SAFE_SQUARE_INDICES_4P = [0, 8, 13, 21, 26, 34, 39, 47];
        const DEFAULT_PLAYER_GEOMETRY_BASE = [ 
            { nameRef:'Red', homeArea: { x: 0, y: 0, w: 6, h: 6 }, startSquareGrid: [1, 6], startPosGlobal: 0, homePathEntryGlobalTrackPos: 50, homePathSquaresGrid: [[6,1],[6,2],[6,3],[6,4],[6,5],[6,6]] },
            { nameRef:'Green', homeArea: { x: 9, y: 0, w: 6, h: 6 }, startSquareGrid: [8, 1], startPosGlobal: 13, homePathEntryGlobalTrackPos: 11, homePathSquaresGrid: [[13,6],[12,6],[11,6],[10,6],[9,6],[8,6]] },
            { nameRef:'YellowVisual', homeArea: { x: 9, y: 9, w: 6, h: 6 }, startSquareGrid: [6, 13], startPosGlobal: 26, homePathEntryGlobalTrackPos: 24, homePathSquaresGrid: [[8,13],[8,12],[8,11],[8,10],[8,9],[8,8]] },
            { nameRef:'BlueVisual', homeArea: { x: 0, y: 9, w: 6, h: 6 }, startSquareGrid: [13, 8], startPosGlobal: 39, homePathEntryGlobalTrackPos: 37, homePathSquaresGrid: [[1,8],[2,8],[3,8],[4,8],[5,8],[6,8]] }
        ];
        const PURPLE_6P_STAGING = { nameRef:'Purple', homeArea: { x: 0.5, y: 7, w: 3, h: 2 }, pathGeomAlias: DEFAULT_PLAYER_GEOMETRY_BASE[0]};
        const ORANGE_6P_STAGING = { nameRef:'Orange', homeArea: { x: 11.5, y: 7, w: 3, h: 2 }, pathGeomAlias: DEFAULT_PLAYER_GEOMETRY_BASE[1]};

        // --- Game State Variables ---
        let selectedBetAmount = BET_AMOUNTS[0], selectedPlayerCount = 0, gameDifficulty = 'medium';
        let playerCoins = 0, playerWins = 0, playerGamesPlayed = 0;
        let players = [], playerCount = 0, currentPlayerTurnIndex = 0, currentDiceValue = 0;
        let gameActive = false, turnOrder = [], humanPlayerCanMove = false, possibleMovesForHuman = [];
        let countdownInterval, extraTurnReason = null, gamePot = 0;
        let gameStats = { captures:0, turns:0, sixesRolled:0}; // For current game

        const baseColors = [ 
            { name: 'Red',    code: 'var(--red)'},    { name: 'Green',  code: 'var(--green)'},
            { name: 'Yellow', code: 'var(--yellow)'}, { name: 'Blue',   code: 'var(--blue)'},
            { name: 'Purple', code: 'var(--purple)'},{ name: 'Orange', code: 'var(--orange)'}
        ];
        
        // --- Player Profile & Coin Management ---
        function initPlayerProfile() {
            const storedCoins = localStorage.getItem(LS_KEYS.COINS);
            const joiningBonusReceived = localStorage.getItem(LS_KEYS.BONUS_RECEIVED) === 'true';
            if (storedCoins === null) {
                playerCoins = JOINING_BONUS_AMOUNT;
                localStorage.setItem(LS_KEYS.COINS, playerCoins.toString());
                localStorage.setItem(LS_KEYS.BONUS_RECEIVED, 'true');
                 setTimeout(() => alert(`Welcome to Ultimate Ludo!\nYou've received ${JOINING_BONUS_AMOUNT} joining bonus coins!`), 200);
            } else {
                playerCoins = parseInt(storedCoins);
                if (!joiningBonusReceived && playerCoins < JOINING_BONUS_AMOUNT) { 
                    playerCoins += JOINING_BONUS_AMOUNT;
                    localStorage.setItem(LS_KEYS.COINS, playerCoins.toString());
                    localStorage.setItem(LS_KEYS.BONUS_RECEIVED, 'true');
                    setTimeout(() => alert(`Welcome back! We've topped up your account with ${JOINING_BONUS_AMOUNT} bonus coins!`), 200);
                }
            }
            playerWins = parseInt(localStorage.getItem(LS_KEYS.WINS) || '0');
            playerGamesPlayed = parseInt(localStorage.getItem(LS_KEYS.GAMES_PLAYED) || '0');
            updateProfileDisplay(); setupBetOptions(); setupPlayerCountOptions();
            document.getElementById('gameDifficulty').value = gameDifficulty; // Set default
        }
        function updateProfileDisplay() {
             document.getElementById('playerCoins').textContent = playerCoins.toLocaleString();
             document.getElementById('playerWins').textContent = playerWins;
             document.getElementById('playerGamesPlayed').textContent = playerGamesPlayed;
             const winRate = playerGamesPlayed > 0 ? ((playerWins / playerGamesPlayed) * 100).toFixed(1) : 0;
             document.getElementById('playerWinRate').textContent = `${winRate}%`;
             updateBetInfoDisplay(); checkAdRewardStatus();
        }
        function updateBetInfoDisplay() {
            document.getElementById('currentBetDisplay').textContent = `Your Bet: ${selectedBetAmount.toLocaleString()}`;
            const potentialWin = selectedPlayerCount > 0 ? (selectedBetAmount * selectedPlayerCount) - selectedBetAmount : selectedBetAmount;
            document.getElementById('potentialWinDisplay').textContent = `Potential Win: ${potentialWin.toLocaleString()}`;
        }
        function addCoins(amount) { playerCoins += amount; localStorage.setItem(LS_KEYS.COINS, playerCoins.toString()); updateProfileDisplay(); playSound('coinSound');}
        function deductCoins(amount) { playerCoins -= amount; localStorage.setItem(LS_KEYS.COINS, playerCoins.toString()); updateProfileDisplay(); }
        function incrementWins() { playerWins++; localStorage.setItem(LS_KEYS.WINS, playerWins.toString()); }
        function incrementGamesPlayed() { playerGamesPlayed++; localStorage.setItem(LS_KEYS.GAMES_PLAYED, playerGamesPlayed.toString()); }

        function checkAdRewardStatus() { /* ... same (using LS_KEYS) ... */ 
            const today = new Date().toISOString().split('T')[0];
            const lastAdDate = localStorage.getItem(LS_KEYS.AD_DATE);
            let todayAdCoins = (lastAdDate === today) ? parseInt(localStorage.getItem(LS_KEYS.AD_COINS) || '0') : 0;
            if (lastAdDate !== today) { localStorage.setItem(LS_KEYS.AD_DATE, today); localStorage.setItem(LS_KEYS.AD_COINS, '0'); }
            const adButton = document.getElementById('watchAdButton'); const adMessage = document.getElementById('adRewardMessage');
            adButton.disabled = (todayAdCoins >= DAILY_AD_COIN_LIMIT);
            adMessage.textContent = adButton.disabled ? `Daily ad reward limit reached.` : `Earn ${AD_REWARD_AMOUNT} coins. (${DAILY_AD_COIN_LIMIT - todayAdCoins} left)`;
        }
        function watchAdForCoins() { /* ... same (using LS_KEYS) ... */
            const adButton = document.getElementById('watchAdButton'); adButton.disabled = true; adButton.textContent = "Loading Ad...";
            setTimeout(() => {
                addCoins(AD_REWARD_AMOUNT); 
                let todayAdCoins = parseInt(localStorage.getItem(LS_KEYS.AD_COINS) || '0') + AD_REWARD_AMOUNT;
                localStorage.setItem(LS_KEYS.AD_COINS, todayAdCoins.toString());
                alert(`You earned ${AD_REWARD_AMOUNT} coins!`); adButton.textContent = `Watch Ad for Coins (+${AD_REWARD_AMOUNT})`;
                checkAdRewardStatus();
            }, 1500);
        }

        function setupBetOptions() { /* ... same, calls updateBetInfoDisplay ... */
            const container = document.getElementById('betOptionsContainer'); container.innerHTML = '';
            BET_AMOUNTS.forEach(amount => {
                const button = document.createElement('div'); button.className = 'bet-option';
                button.textContent = amount >= 1000000 ? `${amount/1000000}M` : (amount >= 1000 ? `${amount/1000}K` : amount.toString());
                button.dataset.value = amount; if (amount === selectedBetAmount) button.classList.add('selected');
                button.onclick = () => {
                    selectedBetAmount = amount; document.querySelectorAll('.bet-option').forEach(btn => btn.classList.remove('selected'));
                    button.classList.add('selected'); updateBetInfoDisplay();
                };
                container.appendChild(button);
            });
             updateBetInfoDisplay();
        }
        function setupPlayerCountOptions() { /* ... same, calls updateBetInfoDisplay ... */
            const container = document.getElementById('playerOptionsContainer');
            container.querySelectorAll('.player-option').forEach(option => {
                option.onclick = () => {
                    selectedPlayerCount = parseInt(option.dataset.value);
                    container.querySelectorAll('.player-option').forEach(btn => btn.classList.remove('selected'));
                    option.classList.add('selected'); updateBetInfoDisplay();
                }
            });
        }
        
        function validateAndStartGame() {
            if (selectedPlayerCount === 0) { alert("Please select the number of players."); return; }
            if (playerCoins < selectedBetAmount) { alert(`Not enough coins for this bet.\nYour Bet: ${selectedBetAmount.toLocaleString()}\nYour Coins: ${playerCoins.toLocaleString()}`); return; }
            
            deductCoins(selectedBetAmount); // Human player pays their bet
            gamePot = selectedBetAmount * selectedPlayerCount; 
            gameDifficulty = document.getElementById('gameDifficulty').value;
            playerCount = selectedPlayerCount; // Set global Ludo playerCount
            startGameSetupInternal(playerCount); 
        }
        
        // --- Board Config & Game Init ---
        function configureBoardLayout() { /* ... same logic, assigns to ACTIVE_* vars ... */ 
            GRID_SIZE = 15; MAIN_TRACK_LENGTH = 52;
            ACTIVE_MAIN_TRACK_COORDS = [...DEFAULT_MAIN_TRACK_COORDS_4P];
            ACTIVE_SAFE_SQUARE_INDICES = [...DEFAULT_SAFE_SQUARE_INDICES_4P];
            let tempGeomConfig = JSON.parse(JSON.stringify(DEFAULT_PLAYER_GEOMETRY_BASE)); 

            if (playerCount === 6) {
                TOKEN_RADIUS = CELL_SIZE * 0.28; 
                let purpleData = JSON.parse(JSON.stringify(PURPLE_6P_STAGING)); // homeArea + pathGeomAlias
                let orangeData = JSON.parse(JSON.stringify(ORANGE_6P_STAGING));
                ACTIVE_PLAYER_GEOMETRY_CONFIG = [
                    tempGeomConfig[0], tempGeomConfig[1], tempGeomConfig[2], tempGeomConfig[3],
                    { ...purpleData, ...purpleData.pathGeomAlias }, // Merge homeArea with path data
                    { ...orangeData, ...orangeData.pathGeomAlias }
                ];
                 ACTIVE_PLAYER_GEOMETRY_CONFIG[4].nameRef = "Purple"; // Ensure correct name
                 ACTIVE_PLAYER_GEOMETRY_CONFIG[5].nameRef = "Orange";
            } else if (playerCount === 3) { 
                 ACTIVE_PLAYER_GEOMETRY_CONFIG = [tempGeomConfig[0], tempGeomConfig[1], tempGeomConfig[2]]; // R,G,YellowVisual
            } else if (playerCount === 2) { 
                ACTIVE_PLAYER_GEOMETRY_CONFIG = [tempGeomConfig[0], tempGeomConfig[2]]; // R,YellowVisual
            } else { 
                ACTIVE_PLAYER_GEOMETRY_CONFIG = tempGeomConfig.slice(0, 4);
            }
            CELL_SIZE = canvasEl.width / GRID_SIZE;
            TOKEN_RADIUS = TOKEN_RADIUS || CELL_SIZE * 0.30; // Use value set by 6P or default
        }

        function startGameSetupInternal(countFromSelection) { /* ... (Reset gameStats) ... */
            playerCount = countFromSelection; configureBoardLayout(); 
            gameStats = { captures:0, turns:0, sixesRolled:0, playerMoves: Array(playerCount).fill(0) }; // Reset game specific stats
            document.getElementById('playerSelectionScreen').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'flex';
            document.getElementById('gamePotDisplay').textContent = gamePot.toLocaleString();
            
            setupTurnOrderInputs(); initLudoGameCore(); 
            const bgMusic = document.getElementById('backgroundMusic');
            if (document.getElementById('soundEffects').checked && bgMusic && typeof bgMusic.play === 'function') {
                bgMusic.volume = 0.15; bgMusic.play().catch(e => console.warn("Autoplay music error:", e));
            }
        }
        function initLudoGameCore() { /* ... same as before ... */
            players = [];
            for (let i = 0; i < playerCount; i++) {
                const playerColorInfo = baseColors[i]; 
                const geometry = ACTIVE_PLAYER_GEOMETRY_CONFIG[i]; 
                if (!geometry) { console.error(`No geometry for player ${i} (color ${playerColorInfo.name}) with ${playerCount} players.`); continue; }
                players.push({
                    name: playerColorInfo.name, color: playerColorInfo.code, isAI: false, 
                    geometry: geometry, colorIndexGlobal: i, 
                    tokens: Array(TOKENS_PER_PLAYER).fill(null).map((_, k) => ({
                        id: k, state: 'home', position: -1, globalTrackPos: -1, displayPos: { x: 0, y: 0 }
                    })),
                    finishedTokens: 0, movesMadeThisGame: 0, capturesMadeThisGame: 0 // Per-player game stats
                });
            }
            updateTurnOrder(); currentDiceValue = 0; gameActive = true; humanPlayerCanMove = false;
            possibleMovesForHuman = []; extraTurnReason = null;

            const aiVsAi = document.getElementById('aiVsAi').checked;
            const autoMode = document.getElementById('autoMode').checked;
            players.forEach((p, idx) => { 
                if (aiVsAi) p.isAI = true;
                else p.isAI = (p.name !== baseColors[0].name) && autoMode;
            });
            if (playerCount === 1 && players[0] && !aiVsAi) players[0].isAI = false;

            updateCurrentPlayerDisplay(); updateTokenBalances(); drawBoard(); 
            const firstPlayer = players[turnOrder[currentPlayerTurnIndex]];
            if (firstPlayer) {
                showGameMessage(`${firstPlayer.name}'s turn. Roll dice.`);
                if (firstPlayer.isAI && document.getElementById('autoRoll').checked) startCountdown(handleDiceRollAction);
            } else showGameMessage("Error: No first player. Please reset.");
            
            document.getElementById('dice').removeEventListener('click', handleDiceRollAction); 
            document.getElementById('dice').addEventListener('click', handleDiceRollAction);
            canvasEl.removeEventListener('click', handleCanvasClick);
            canvasEl.addEventListener('click', handleCanvasClick);
            
            document.getElementById('backButton').style.display = 'block'; document.getElementById('closeButton').style.display = 'block';
            document.getElementById('backButton').onclick = () => showExitConfirmation('exit_to_menu_forfeit_if_active'); // More specific action names
            document.getElementById('closeButton').onclick = () => showExitConfirmation('quit_current_game_forfeit');
        }

        // --- Draw, Move, AI, UI (many functions same as "cone" version) ---
        function drawBoard() { /* ... cone logic and uses ACTIVE_* vars, ensure players[geomIndex] exists ... */ 
             ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--board-bg').trim();
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            ACTIVE_PLAYER_GEOMETRY_CONFIG.forEach((geom, geomIndex) => {
                if (geomIndex >= playerCount || !players[geomIndex]) return; 
                let displayColor = players[geomIndex].color; let borderColor = getBorderColor(displayColor);
                ctx.lineWidth = 1; 
                for (let r = 0; r < geom.homeArea.h; r++) {
                    for (let c = 0; c < geom.homeArea.w; c++) {
                        ctx.fillStyle = displayColor; 
                        ctx.fillRect((geom.homeArea.x + c) * CELL_SIZE, (geom.homeArea.y + r) * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        ctx.strokeStyle = borderColor;
                        ctx.strokeRect((geom.homeArea.x + c) * CELL_SIZE, (geom.homeArea.y + r) * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
                ctx.strokeStyle = borderColor; ctx.lineWidth = 2.5; 
                ctx.strokeRect(geom.homeArea.x * CELL_SIZE, geom.homeArea.y * CELL_SIZE, geom.homeArea.w * CELL_SIZE, geom.homeArea.h * CELL_SIZE);
                
                geom.homePathSquaresGrid.forEach((sq) => {
                    ctx.fillStyle = displayColor; 
                    ctx.fillRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    ctx.strokeStyle = borderColor; ctx.lineWidth = 1;
                    ctx.strokeRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                });
            });

            ACTIVE_MAIN_TRACK_COORDS.forEach((sq, index) => {
                ACTIVE_PLAYER_GEOMETRY_CONFIG.forEach((geom, playerGeomIndex) => {
                    if (playerGeomIndex >= playerCount || !players[playerGeomIndex]) return;
                    const playerAssociatedWithGeom = players[playerGeomIndex]; const armLength = 5; 
                    if (index >= geom.startPosGlobal && index < geom.startPosGlobal + armLength) {
                        if (!ACTIVE_SAFE_SQUARE_INDICES.includes(index) && index !== geom.startPosGlobal) {
                            ctx.fillStyle = playerAssociatedWithGeom.color.replace(')', ', 0.18)').replace('var(', 'rgba(');
                            ctx.fillRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        }
                    }
                });
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim();
                ctx.lineWidth = 1; ctx.strokeRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                
                ACTIVE_PLAYER_GEOMETRY_CONFIG.forEach((geom, geomIndex) => {
                    if (geomIndex >= playerCount || !players[geomIndex]) return;
                    if (geom.startPosGlobal === index) {
                        ctx.fillStyle = players[geomIndex].color.replace(')', ', 0.45)').replace('var(', 'rgba('); 
                        ctx.fillRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        ctx.strokeStyle = getBorderColor(players[geomIndex].color);
                        ctx.strokeRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                });
                if (ACTIVE_SAFE_SQUARE_INDICES.includes(index)) {
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--safe-star-color').trim();
                    ctx.fillRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE); 
                    ctx.fillStyle = '#000'; ctx.font = `${CELL_SIZE * 0.65}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText('‚òÖ', (sq[0] + 0.5) * CELL_SIZE, (sq[1] + 0.55) * CELL_SIZE); 
                    ctx.strokeStyle = '#8c7000'; ctx.lineWidth = 1.5;
                    ctx.strokeRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            });
            
            const mid = Math.floor(GRID_SIZE / 2);
            ctx.beginPath();
            ctx.moveTo((mid -1) * CELL_SIZE, mid * CELL_SIZE); ctx.lineTo(mid * CELL_SIZE, (mid-1) * CELL_SIZE);
            ctx.lineTo((mid +1) * CELL_SIZE, mid * CELL_SIZE); ctx.lineTo(mid * CELL_SIZE, (mid+1) * CELL_SIZE);
            ctx.closePath(); ctx.fillStyle = '#e0e0e0'; ctx.fill();
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim();
            ctx.lineWidth = 1.5; ctx.stroke();

            players.forEach((player, playerIdx) => { /* ... same code for drawing tokens ... */
                if (!player || !player.tokens || !player.geometry) return;
                const geom = player.geometry;
                player.tokens.forEach((token, tokenIdx) => {
                    let x, yDraw; 
                    if (token.state === 'home') {
                        const homeCellWidth = geom.homeArea.w / 2; const homeCellHeight = geom.homeArea.h / 2;
                        const tokenCellXCenter = (geom.homeArea.x + (tokenIdx % 2) * homeCellWidth + homeCellWidth / 2) * CELL_SIZE;
                        const tokenCellYCenter = (geom.homeArea.y + Math.floor(tokenIdx / 2) * homeCellHeight + homeCellHeight / 2) * CELL_SIZE;
                        x = tokenCellXCenter; const coneTotalVisualHeight = (TOKEN_RADIUS * 1.1) * 2.2;
                        yDraw = tokenCellYCenter + coneTotalVisualHeight * 0.3; 
                    } else if (token.state === 'track') {
                        const globalPos = token.globalTrackPos;
                        if (globalPos !== -1 && globalPos < ACTIVE_MAIN_TRACK_COORDS.length) {
                            const sq = ACTIVE_MAIN_TRACK_COORDS[globalPos];
                            x = (sq[0] + 0.5) * CELL_SIZE; yDraw = (sq[1] + 0.85) * CELL_SIZE; 
                        } else { return; }
                    } else if (token.state === 'homestretch') {
                        if(token.position >= 0 && token.position < geom.homePathSquaresGrid.length) {
                            const sq = geom.homePathSquaresGrid[token.position];
                            x = (sq[0] + 0.5) * CELL_SIZE; yDraw = (sq[1] + 0.85) * CELL_SIZE;
                        } else { return; }
                    } else { 
                        const finalHomeSqIdx = Math.min(HOME_STRETCH_LENGTH -1, geom.homePathSquaresGrid.length -1);
                        const finalHomeSq = geom.homePathSquaresGrid[finalHomeSqIdx];
                        const offsetX = (tokenIdx - (TOKENS_PER_PLAYER -1)/2) * TOKEN_RADIUS * 0.5;
                        x = (finalHomeSq[0] + 0.5) * CELL_SIZE + offsetX; yDraw = (finalHomeSq[1] + 0.85) * CELL_SIZE;
                    }
                    token.displayPos = {x: x, y: yDraw}; 
                    drawToken(x, yDraw, player.color, token, playerIdx);
                });
             });
        }
        function getBorderColor(backgroundColorString) { /* ... same ... */
             if (backgroundColorString.includes('var(--yellow)')) return '#a18800'; 
             if (backgroundColorString.includes('var(--green)')) return '#1a7431';  
             if (backgroundColorString.includes('var(--blue)')) return '#1b608c';   
             if (backgroundColorString.includes('var(--red)')) return '#a02c2c';    
             if (backgroundColorString.includes('var(--purple)')) return '#6a3682'; 
             if (backgroundColorString.includes('var(--orange)')) return '#a85915'; 
             return '#333'; 
        }
        function drawToken(x, y, color, tokenData, playerIndexOfTokenOwner) { /* ... same cone logic ... */ 
            const visualSize = TOKEN_RADIUS * 1.1; const coneHeight = visualSize * 2.2;   
            const baseHeight = coneHeight * 0.20; const baseWidth  = visualSize * 1.8;   
            const bodyHeight = coneHeight - baseHeight; const topPointY = y - coneHeight;         
            const bodyBaseY = y - baseHeight;         
            ctx.save(); ctx.fillStyle = color;
            ctx.fillRect(x - baseWidth / 2, y - baseHeight, baseWidth, baseHeight);
            ctx.beginPath(); ctx.moveTo(x, topPointY); ctx.lineTo(x - baseWidth / 2, bodyBaseY); 
            ctx.lineTo(x + baseWidth / 2, bodyBaseY); ctx.closePath(); ctx.fill();
            const outlineColor = getBorderColor(color); ctx.strokeStyle = outlineColor; ctx.lineWidth = 1.5;
            ctx.strokeRect(x - baseWidth / 2, y - baseHeight, baseWidth, baseHeight);
            ctx.beginPath(); ctx.moveTo(x, topPointY); ctx.lineTo(x - baseWidth / 2, bodyBaseY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(x, topPointY); ctx.lineTo(x + baseWidth / 2, bodyBaseY); ctx.stroke();
            if (gameActive && players.length > 0 && turnOrder.length > 0 && players[turnOrder[currentPlayerTurnIndex]]) { 
                const currentPlayerRealIndex = turnOrder[currentPlayerTurnIndex];
                if (humanPlayerCanMove && playerIndexOfTokenOwner === currentPlayerRealIndex) {
                    const isMovable = possibleMovesForHuman.some(move => move.tokenIndex === tokenData.id);
                    if (isMovable) {
                        ctx.strokeStyle = 'gold'; ctx.lineWidth = 3;
                        ctx.strokeRect(x - baseWidth / 2, y - baseHeight, baseWidth, baseHeight);
                        ctx.beginPath(); ctx.moveTo(x, topPointY); ctx.lineTo(x - baseWidth / 2, bodyBaseY); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(x, topPointY); ctx.lineTo(x + baseWidth / 2, bodyBaseY); ctx.stroke();
                    }
                }
            }
            ctx.restore();
        }

        function animateTokenVisual(playerIndex, tokenIndex, fromGridPos, toGridPos) {
            if (!document.getElementById('animations').checked) return; // Skip if animations are off

            const tokenEl = document.createElement('div');
            tokenEl.className = 'animated-token-visual';
            const player = players[playerIndex];
            tokenEl.style.backgroundColor = player.color.startsWith('var') ? getComputedStyle(document.documentElement).getPropertyValue(player.color.slice(4,-1)).trim() : player.color;
            
            const tokenVisualRadius = TOKEN_RADIUS * 1.1 * 0.9; // Approx visual size of cone base
            tokenEl.style.width = `${tokenVisualRadius * 2}px`;
            tokenEl.style.height = `${tokenVisualRadius * 2}px`; // Simple circle for animation

            const canvasRect = canvasEl.getBoundingClientRect();
            
            // Convert grid positions to absolute screen positions
            const fromScreenX = (fromGridPos.x + 0.5) * CELL_SIZE + canvasRect.left - tokenVisualRadius;
            const fromScreenY = (fromGridPos.y + 0.85) * CELL_SIZE + canvasRect.top - tokenVisualRadius *2 ; // Base of cone is at 0.85

            const toScreenX = (toGridPos.x + 0.5) * CELL_SIZE + canvasRect.left - tokenVisualRadius;
            const toScreenY = (toGridPos.y + 0.85) * CELL_SIZE + canvasRect.top - tokenVisualRadius*2 ;

            tokenEl.style.left = `${fromScreenX}px`;
            tokenEl.style.top = `${fromScreenY}px`;
            
            document.body.appendChild(tokenEl);

            requestAnimationFrame(() => { // Ensure initial style is applied
                 tokenEl.style.transform = `translate(${toScreenX - fromScreenX}px, ${toScreenY - fromScreenY}px)`;
            });

            setTimeout(() => {
                tokenEl.remove();
            }, 500); // Duration of CSS transition
        }

        function getPossibleMoves(playerIndex, diceRoll) { /* ... (same as your previous version using ACTIVE_PLAYER_GEOMETRY_CONFIG) ... */ 
            const player = players[playerIndex]; const moves = [];
            if (!player || !player.tokens || !player.geometry) return moves;
            player.tokens.forEach((token, tokenIdx) => {
                if (token.state === 'finished') return;
                if (token.state === 'home') {
                    if (diceRoll === 6) {
                        const startGlobalPos = player.geometry.startPosGlobal;
                        let ownTokensOnStart = player.tokens.filter(t => t.state === 'track' && t.globalTrackPos === startGlobalPos).length;
                        if (ownTokensOnStart < 2) moves.push({ tokenIndex: tokenIdx, fromState: 'home', toState: 'track', newPosition: 0, newGlobalTrackPos: player.geometry.startPosGlobal });
                    }
                } else if (token.state === 'track') {
                    const currentTrackProgress = token.position; const newTrackProgress = currentTrackProgress + diceRoll;
                    let stepsToHomeEntrySquare;
                    if (player.geometry.homePathEntryGlobalTrackPos >= player.geometry.startPosGlobal) stepsToHomeEntrySquare = player.geometry.homePathEntryGlobalTrackPos - player.geometry.startPosGlobal;
                    else stepsToHomeEntrySquare = MAIN_TRACK_LENGTH - player.geometry.startPosGlobal + player.geometry.homePathEntryGlobalTrackPos;

                    if (newTrackProgress <= stepsToHomeEntrySquare) {
                        const newGlobalPos = (player.geometry.startPosGlobal + newTrackProgress) % MAIN_TRACK_LENGTH;
                        moves.push({ tokenIndex: tokenIdx, fromState: 'track', toState: 'track', newPosition: newTrackProgress, newGlobalTrackPos: newGlobalPos });
                    } else {
                        const stepsIntoHomeStretch = newTrackProgress - (stepsToHomeEntrySquare + 1);
                        if (stepsIntoHomeStretch < HOME_STRETCH_LENGTH -1) moves.push({ tokenIndex: tokenIdx, fromState: 'track', toState: 'homestretch', newPosition: stepsIntoHomeStretch, newGlobalTrackPos: -1 });
                        else if (stepsIntoHomeStretch === HOME_STRETCH_LENGTH -1 ) moves.push({ tokenIndex: tokenIdx, fromState: 'track', toState: 'finished', newPosition: 0, newGlobalTrackPos: -1 });
                    }
                } else if (token.state === 'homestretch') {
                    const newHomePos = token.position + diceRoll;
                    if (newHomePos < HOME_STRETCH_LENGTH -1) moves.push({ tokenIndex: tokenIdx, fromState: 'homestretch', toState: 'homestretch', newPosition: newHomePos, newGlobalTrackPos: -1 });
                    else if (newHomePos === HOME_STRETCH_LENGTH -1) moves.push({ tokenIndex: tokenIdx, fromState: 'homestretch', toState: 'finished', newPosition: 0, newGlobalTrackPos: -1 });
                }
            });
            return moves;
        }
        function executeMove(playerIndex, chosenMove) { /* ... (calls animateTokenVisual if enabled, calls gameEndLogic) ... */
            humanPlayerCanMove = false; const player = players[playerIndex]; const token = player.tokens[chosenMove.tokenIndex];
            const oldGridPos = token.state === 'track' ? ACTIVE_MAIN_TRACK_COORDS[token.globalTrackPos] : (token.state === 'homestretch' ? player.geometry.homePathSquaresGrid[token.position] : player.geometry.homeArea ); // Approx old pos

            token.state = chosenMove.toState; token.position = chosenMove.newPosition;
            token.globalTrackPos = chosenMove.newGlobalTrackPos !== undefined ? chosenMove.newGlobalTrackPos : -1;
            
            const newGridPos = token.state === 'track' ? ACTIVE_MAIN_TRACK_COORDS[token.globalTrackPos] : (token.state === 'homestretch' ? player.geometry.homePathSquaresGrid[token.position] : player.geometry.homeArea ); // Approx new pos
            
            if (oldGridPos && newGridPos && oldGridPos.x !== undefined && newGridPos.x !== undefined) { // Ensure positions are valid for animation
                animateTokenVisual(playerIndex, chosenMove.tokenIndex, oldGridPos, newGridPos);
            }

            playSound('moveSound'); let message = `${player.name} moved a token.`; gameStats.playerMoves[playerIndex]++;

            if (token.state === 'track' && !isSafePosition(token.globalTrackPos)) { /* ... capture logic ... */ 
                 for (let i = 0; i < playerCount; i++) {
                    if (i === playerIndex || !players[i]) continue; 
                    players[i].tokens.forEach(opToken => {
                        if (opToken.state === 'track' && opToken.globalTrackPos === token.globalTrackPos) {
                            opToken.state = 'home'; opToken.position = -1; opToken.globalTrackPos = -1;
                            message = `${player.name} captured ${players[i].name}'s token!`;
                            playSound('captureSound'); extraTurnReason = 'capture'; 
                            gameStats.captures++; player.capturesMadeThisGame++;
                        }
                    });
                }
            }
            if (token.state === 'finished') { /* ... game end logic call ... */
                player.finishedTokens++; message = `${player.name}'s token reached home!`;
                if (player.finishedTokens === TOKENS_PER_PLAYER) { gameEndLogic(playerIndex); return; }
                if (currentDiceValue === 6 && extraTurnReason === 'dice_6') extraTurnReason = 'home_entry_6_no_extra'; 
            }
            if (extraTurnReason === 'home_entry_6_no_extra') extraTurnReason = null;
            showGameMessage(message); updateTokenBalances(); 
            if (!document.getElementById('animations').checked || !oldGridPos) drawBoard(); // Redraw immediately if no animation or from home
            else setTimeout(drawBoard, 500); // Redraw after animation
            setTimeout(nextTurn, document.getElementById('animations').checked ? 600 : 1000); 
        }

        // AI based on Difficulty
        function aiMakeMove(playerIndex, possibleMoves) { /* ... (logic influenced by gameDifficulty) ... */
            const player = players[playerIndex]; let bestMove = null;
            const diff = gameDifficulty;
            const smartCap = document.getElementById('smartCapture').checked;
            const safeMov = document.getElementById('safeMove').checked;
            let aggression = diff === 'hard' ? 0.8 : (diff === 'medium' ? 0.5 : 0.2); // Chance to prioritize aggressive moves
            let caution = diff === 'hard' ? 0.8 : (diff === 'medium' ? 0.5 : 0.2); // Chance to prioritize safe/finishing moves

            // 1. Get out with 6 (always good unless high caution and board is dangerous)
            if (currentDiceValue === 6) {
                const homeMove = possibleMoves.find(m => m.fromState === 'home');
                if (homeMove && (player.tokens.filter(t => t.state !== 'home' && t.state !== 'finished').length < 2 || Math.random() > caution * 0.5) ) {
                    bestMove = homeMove;
                }
            }
            // 2. Capture (if smart and random chance allows or hard difficulty)
            if (!bestMove && smartCap && Math.random() < aggression) { /* ... find capture move ... */ 
                const captureMoves = possibleMoves.filter(m => m.toState === 'track' && !isSafePosition(m.newGlobalTrackPos) && players.some((op, opIdx) => opIdx !== playerIndex && op.tokens.some(ot => ot.state === 'track' && ot.globalTrackPos === m.newGlobalTrackPos)));
                if(captureMoves.length > 0) bestMove = captureMoves[Math.floor(Math.random() * captureMoves.length)];
            }
            // 3. Finish token (high priority with caution)
            if (!bestMove && Math.random() < caution) { /* ... find finishing move ... */
                bestMove = possibleMoves.find(m => m.toState === 'finished') || bestMove;
             }
            // 4. Move to safe square (if enabled and caution)
            if (!bestMove && safeMov && Math.random() < caution * 1.2) { /* ... find safe move ... */ 
                 const safeMoves = possibleMoves.filter(m => m.toState === 'track' && isSafePosition(m.newGlobalTrackPos));
                if (safeMoves.length > 0) bestMove = safeMoves.sort((a,b) => player.tokens[b.tokenIndex].position - player.tokens[a.tokenIndex].position)[0];
            }
            // 5. General advancement / random pick based on difficulty
            if (!bestMove) {
                let candidates = possibleMoves;
                if(diff === 'easy' || candidates.length === 0) { // Easy or no strategic moves found
                    bestMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                } else { // Medium/Hard: Prioritize furthest, or entering home stretch
                    candidates.sort((a,b) => {
                        const scoreA = (a.toState === 'homestretch' ? 200 : (player.tokens[a.tokenIndex].state === 'track' ? 100 : 0)) + player.tokens[a.tokenIndex].position;
                        const scoreB = (b.toState === 'homestretch' ? 200 : (player.tokens[b.tokenIndex].state === 'track' ? 100 : 0)) + player.tokens[b.tokenIndex].position;
                        return scoreB - scoreA;
                    });
                    bestMove = candidates[0];
                }
            }
            if (bestMove) setTimeout(() => { if(gameActive) executeMove(playerIndex, bestMove); }, 300 + Math.random()*500);
            else { if(gameActive) nextTurn(); } // Should not happen if possibleMoves > 0
        }
        
        function isSafePosition(globalTrackPos) { return ACTIVE_SAFE_SQUARE_INDICES.includes(globalTrackPos); }
        function nextTurn() { /* ... (updates gameStats.turns) ... */ 
            gameStats.turns++; // Count total turns in the game
            /* ... rest of nextTurn logic ... */
            humanPlayerCanMove = false; possibleMovesForHuman = []; currentDiceValue = 0; 
            document.getElementById('diceValue').textContent = `Dice: -`;
            const currentPlayerObj = players[turnOrder[currentPlayerTurnIndex]];
            if (extraTurnReason && currentPlayerObj) { 
                showGameMessage(`${currentPlayerObj.name} gets an extra turn (${extraTurnReason.replace(/_/g, ' ')})! Roll dice.`);
                extraTurnReason = null; 
            } else {
                currentPlayerTurnIndex = (currentPlayerTurnIndex + 1) % playerCount;
                updateCurrentPlayerDisplay();
                if (players[turnOrder[currentPlayerTurnIndex]]) showGameMessage(`${players[turnOrder[currentPlayerTurnIndex]].name}'s turn. Roll dice.`);
            }
            const nextPlayer = players[turnOrder[currentPlayerTurnIndex]];
            if (nextPlayer && nextPlayer.isAI && document.getElementById('autoRoll').checked && gameActive) startCountdown(handleDiceRollAction);
            drawBoard(); 
        }

        function updateCurrentPlayerDisplay() { /* ... (same with checks) ... */ 
             if (!gameActive || !players || players.length === 0 || !players[turnOrder[currentPlayerTurnIndex]] || turnOrder.length === 0) {
                document.getElementById('currentPlayer').textContent = "Loading..."; return;
            }
            const player = players[turnOrder[currentPlayerTurnIndex]];
            const display = document.getElementById('currentPlayer');
            display.textContent = `Player: ${player.name}`;
            display.style.color = player.color.startsWith('var') ? getComputedStyle(document.documentElement).getPropertyValue(player.color.slice(4,-1)).trim() : player.color;
        }
        function showGameMessage(message) { document.getElementById('gameMessage').textContent = message; }
        function updateTokenBalances() { /* ... (same with checks) ... */ 
            const container = document.getElementById('tokenBalances'); container.innerHTML = '';
            players.forEach(player => {
                if(!player) return;
                const balanceElement = document.createElement('div');
                balanceElement.className = 'token-balance';
                balanceElement.style.background = player.color.startsWith('var') ? getComputedStyle(document.documentElement).getPropertyValue(player.color.slice(4,-1)).trim() : player.color;;
                balanceElement.style.color = getBorderColor(player.color) === '#333' || getBorderColor(player.color) === '#a18800' || getBorderColor(player.color) === '#1a7431' ? 'white' : 'var(--dark-gray)'; // Text color contrast
                const tokensLeft = TOKENS_PER_PLAYER - player.finishedTokens;
                balanceElement.textContent = `${player.name}: ${tokensLeft}`;
                container.appendChild(balanceElement);
            });
        }
         function handleCanvasClick(event) { /* ... (cone click detection from your 'cone' version) ... */
             if (!humanPlayerCanMove || !gameActive) return;
            const rect = canvasEl.getBoundingClientRect();
            const clickX = event.clientX - rect.left; const clickY = event.clientY - rect.top;
            if (!players || players.length === 0 || turnOrder.length === 0) return;
            const playerIndex = turnOrder[currentPlayerTurnIndex]; const player = players[playerIndex];
            if (!player || !player.tokens) return;
            for (const move of possibleMovesForHuman) {
                const token = player.tokens[move.tokenIndex];
                if (!token.displayPos || token.displayPos.x == undefined || token.displayPos.y == undefined) continue; 
                const visualSize = TOKEN_RADIUS * 1.1; const coneTotalHeight = visualSize * 2.2; const coneBaseWidth = visualSize * 1.8;
                const coneVisualCenterX = token.displayPos.x; const coneVisualCenterY = token.displayPos.y - coneTotalHeight / 2; 
                const dx = clickX - coneVisualCenterX; const dy = clickY - coneVisualCenterY;
                const clickRadiusX = coneBaseWidth * 0.7; const clickRadiusY = coneTotalHeight * 0.5;
                if (Math.abs(dx) < clickRadiusX && Math.abs(dy) < clickRadiusY) {
                    executeMove(playerIndex, move); humanPlayerCanMove = false; 
                    possibleMovesForHuman = []; 
                    if(!document.getElementById('animations').checked) drawBoard(); // Redraw immediately if no animation
                    return;
                }
            }
          }
        function startCountdown(callback) { /* ... (same with gameActive check in callback) ... */ 
             clearInterval(countdownInterval); const bar = document.getElementById('countdownBar');
            if (!bar) return; 
            bar.style.width = '100%'; let timeLeft = 100; 
            countdownInterval = setInterval(() => {
                timeLeft -= 5; bar.style.width = `${Math.max(0, timeLeft)}%`;
                if (timeLeft <= 0) { clearInterval(countdownInterval); if (gameActive) callback(); }
            }, 100); 
        }
        function playSound(soundId) { /* ... (same with getElementById check) ... */ 
            const soundEnabled = document.getElementById('soundEffects')?.checked;
            if (soundEnabled) {
                const sound = document.getElementById(soundId);
                if (sound && typeof sound.play === 'function') {
                    sound.currentTime = 0; sound.play().catch(e => console.warn(`Sound ${soundId} play error:`, e));
                }
            }
        }
        function setupTurnOrderInputs() { /* ... (same) ... */
             const container = document.getElementById('customTurnOrderContainer');
            const button = container.querySelector('button'); 
            container.innerHTML = '<label>Turn Order:</label>'; 
            if (button) container.appendChild(button); 
            for (let i = 0; i < playerCount; i++) {
                const input = document.createElement('input');
                input.type = 'text'; input.id = `turn${baseColors[i].name}`;
                input.placeholder = (i + 1).toString(); input.value = (i + 1).toString();
                input.style.borderColor = baseColors[i].code.startsWith('var') ? getComputedStyle(document.documentElement).getPropertyValue(baseColors[i].code.slice(4,-1)).trim() : baseColors[i].code;
                if(button) container.insertBefore(input, button); else container.appendChild(input);
            }
        }
        function updateTurnOrder() { /* ... (same) ... */
            const newOrderPreferences = [];
            for (let i = 0; i < playerCount; i++) {
                const input = document.getElementById(`turn${baseColors[i].name}`);
                const orderVal = parseInt(input?.value) || (i + 1); 
                newOrderPreferences.push({ playerIndex: i, order: orderVal });
            }
            newOrderPreferences.sort((a, b) => a.order - b.order);
            turnOrder = newOrderPreferences.map(item => item.playerIndex);
            currentPlayerTurnIndex = 0; 
            updateCurrentPlayerDisplay();
            const firstPlayer = players[turnOrder[currentPlayerTurnIndex]];
            if (firstPlayer) { 
                 showGameMessage(`Turn order updated. ${firstPlayer.name}'s turn.`);
                 if (gameActive && firstPlayer.isAI && document.getElementById('autoRoll').checked) startCountdown(handleDiceRollAction);
            }
        }
         function handleDiceRollAction() { /* ... (same complex logic) ... */
             if (!gameActive || humanPlayerCanMove) return; 
            if (!players || players.length === 0 || turnOrder.length === 0 || !players[turnOrder[currentPlayerTurnIndex]]) return;
            const player = players[turnOrder[currentPlayerTurnIndex]];
            const player0IsHuman = (!document.getElementById('autoMode').checked && turnOrder[currentPlayerTurnIndex] === 0 && !document.getElementById('aiVsAi').checked) || (turnOrder[currentPlayerTurnIndex] === 0 && !document.getElementById('aiVsAi').checked && !player.isAI);
            if (player.isAI || player0IsHuman) rollDice();
            else if (!player.isAI && turnOrder[currentPlayerTurnIndex] !== 0 && !document.getElementById('autoMode').checked) rollDice();
         }
         function rollDice() { /* ... (adds to gameStats.sixesRolled) ... */ 
             if (!gameActive) return;
            const diceElement = document.getElementById('dice');
            if(document.getElementById('animations').checked) diceElement.classList.add('animate');
            playSound('diceSound');
            setTimeout(() => {
                if (!gameActive) return;
                currentDiceValue = Math.floor(Math.random() * 6) + 1;
                if (currentDiceValue === 6) gameStats.sixesRolled++;
                diceElement.textContent = getDiceFace(currentDiceValue);
                diceElement.classList.remove('animate');
                document.getElementById('diceValue').textContent = `Dice: ${currentDiceValue}`;
                extraTurnReason = (currentDiceValue === 6) ? 'dice_6' : null;
                processPlayerTurn();
            }, document.getElementById('animations').checked ? 800 : 100); // Shorter delay if no animation
        }
         function processPlayerTurn() { /* ... (same) ... */ 
             if (!gameActive || !players || players.length === 0 || turnOrder.length === 0 || !players[turnOrder[currentPlayerTurnIndex]]) return;
            const playerIndex = turnOrder[currentPlayerTurnIndex]; const player = players[playerIndex];
            possibleMovesForHuman = getPossibleMoves(playerIndex, currentDiceValue);
            if (possibleMovesForHuman.length === 0) {
                showGameMessage(`${player.name} rolled ${currentDiceValue}. No moves available.`);
                playSound('errorSound'); setTimeout(() => { if(gameActive) nextTurn(); }, 1500);
            } else {
                if (player.isAI) {
                    showGameMessage(`${player.name} (AI) rolled ${currentDiceValue}. Thinking...`);
                    aiMakeMove(playerIndex, possibleMovesForHuman);
                } else { 
                    humanPlayerCanMove = true;
                    showGameMessage(`${player.name}, select a token to move ${currentDiceValue}.`); drawBoard(); 
                }
            }
        }
        function getDiceFace(value) { const faces = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ']; return faces[value - 1]; }

        // --- End Game, Quit, Reset ---
        function gameEndLogic(winnerPlayerIndex, isForfeit = false, forfeitingPlayerIndex = -1) { /* ... (updates gamesPlayed, adds winStats, triggers confetti) ... */ 
            if (!gameActive) return; gameActive = false; clearInterval(countdownInterval);
            incrementGamesPlayed(); // Increment total games played by human user
            
            const winner = players[winnerPlayerIndex];
            const humanPlayerObject = players.find(p => !p.isAI && p.name === baseColors[0].name ); // Better find human based on initial color index for stats
            
            if (winner) { 
                if (humanPlayerObject && humanPlayerObject.name === winner.name && !isForfeit) {
                    incrementWins(); addCoins(gamePot); 
                } else if (isForfeit && humanPlayerObject && humanPlayerObject.name === players[forfeitingPlayerIndex]?.name) {
                     // Handled by confirmQuit, human's bet is just lost if they forfeit
                } else if (humanPlayerObject && !isForfeit && humanPlayerObject.name !== winner.name){ 
                    // If human was playing and didn't win in a normal game
                }
                // If it's an AI vs AI game and AI wins, human user doesn't get coins unless they were betting on AI. (Not implemented)
            }
            updateProfileDisplay();

            const winStatsEl = document.getElementById('winStats');
            if(winStatsEl) winStatsEl.innerHTML = winner ? `
                <span>Game Turns: ${gameStats.turns}</span>
                <span>Winner's Moves: ${winner.movesMadeThisGame}</span>
                <span>Winner's Captures: ${winner.capturesMadeThisGame}</span>
                <span>Total Captures: ${gameStats.captures}</span>
                <span>Sixes Rolled: ${gameStats.sixesRolled}</span>
            ` : 'No game stats available.';
            if (document.getElementById('animations').checked && !isForfeit && winner) triggerConfetti();

            const overlayId = isForfeit ? 'forcedCloseOverlay' : 'winMessage'; /* ... (rest of modal display logic) ... */
            const titleEl = isForfeit ? document.getElementById('forcedCloseTitle') : document.getElementById('winnerText');
            const detailsEl = isForfeit ? document.getElementById('forcedCloseMessage') : document.getElementById('winDetails');
            const winPotInfo = document.getElementById('winPotInfo'); // Only in winMessage
            if (winPotInfo) winPotInfo.style.display = 'none'; // Hide by default for forfeits


            if (isForfeit) {
                const forfeiterName = forfeitingPlayerIndex !== -1 && players[forfeitingPlayerIndex] ? players[forfeitingPlayerIndex].name : "A player";
                titleEl.textContent = `${forfeiterName} Left!`;
                if(winner) detailsEl.textContent = `${winner.name} wins the pot of ${gamePot.toLocaleString()} coins!`;
                else detailsEl.textContent = "Game abandoned. No winner declared.";
                
                let timeLeft = 5; document.getElementById('forcedCloseTimer').textContent = timeLeft;
                const timerInterval = setInterval(() => {
                    timeLeft--; document.getElementById('forcedCloseTimer').textContent = timeLeft;
                    if (timeLeft <= 0) { clearInterval(timerInterval); returnToHome(); }
                }, 1000);
            } else {
                if(winner){
                    titleEl.textContent = `${winner.name} Wins!`; titleEl.style.color = winner.color.startsWith('var') ? getComputedStyle(document.documentElement).getPropertyValue(winner.color.slice(4,-1)).trim() : winner.color;
                    detailsEl.textContent = `Congratulations!`;
                    if(winPotInfo) { document.getElementById('winPotAmount').textContent = gamePot.toLocaleString(); winPotInfo.style.display = 'block';}
                } else {
                    titleEl.textContent = "Game Over"; detailsEl.textContent = "The game has ended.";
                }
            }
            document.getElementById(overlayId).style.display = 'flex'; playSound('winSound');
            const bgMusic = document.getElementById('backgroundMusic');
            if (bgMusic && typeof bgMusic.pause === 'function') bgMusic.pause();
        }
        function showExitConfirmation(actionType) { /* ... same, using clearer action names passed ... */ 
            const dialog = document.getElementById('exitConfirmation');
            const titleEl = document.getElementById('exitDialogTitle'); const msgEl = document.getElementById('exitDialogMessage');
            const confirmBtn = document.getElementById('confirmExitButton');

            if (actionType === 'reset') {
                titleEl.textContent = 'Reset Game'; msgEl.textContent = 'This will forfeit the current game and your bet. Start a new game with the same settings?';
                confirmBtn.textContent = 'Yes, Reset'; confirmBtn.onclick = confirmReset;
            } else if (actionType === 'exit_to_menu_forfeit_if_active') { // Back button
                if(gameActive) {
                    titleEl.textContent = 'Quit to Menu'; msgEl.textContent = 'Are you sure? You will forfeit the game and your bet.';
                    confirmBtn.textContent = 'Yes, Quit'; confirmBtn.onclick = confirmQuitGame; 
                } else {
                    returnToHome(); return; // If game not active, just go home
                }
            } else { // quit_current_game_forfeit (Close button)
                titleEl.textContent = 'Quit Game'; msgEl.textContent = 'Are you sure? You will forfeit the game and your bet.';
                confirmBtn.textContent = 'Yes, Quit'; confirmBtn.onclick = confirmQuitGame; 
            }
            dialog.style.display = 'flex';
        }
        function cancelExit() { document.getElementById('exitConfirmation').style.display = 'none';}
        function confirmQuitGame() { /* ... (same logic but human player may not be player 0) ... */ 
            document.getElementById('exitConfirmation').style.display = 'none'; if (!gameActive) { returnToHome(); return; }
            const humanPlayerObject = players.find(p => !p.isAI && p.name === baseColors[0].name );
            const humanPlayerIndex = humanPlayerObject ? players.indexOf(humanPlayerObject) : -1;
            if (humanPlayerObject) incrementGamesPlayed(); // Game was played if human forfeits

            let winner = null;
            if (playerCount > 1 && humanPlayerIndex !== -1) { 
                 const otherPlayers = players.filter((p, idx) => idx !== humanPlayerIndex);
                 if(otherPlayers.length > 0) winner = otherPlayers[0]; 
            } else if (playerCount > 1) { // AI vs AI, and quit, pick first player as nominal winner
                 winner = players[0];
            }
            
            if (winner) gameEndLogic(players.indexOf(winner), true, humanPlayerIndex);
            else gameEndLogic(-1, true, humanPlayerIndex); 
        }
        function confirmReset() { /* ... (same, with bet handling & gamesPlayed update) ... */ 
            document.getElementById('exitConfirmation').style.display = 'none'; if (!gameActive) { initPlayerProfile(); return; }
            incrementGamesPlayed(); // Resetting is like playing and losing a game
            // Bet for current game is lost (already deducted). We need to deduct for the new game.
            if (playerCoins < selectedBetAmount) {
                alert(`Cannot start new game. Not enough coins for bet of ${selectedBetAmount.toLocaleString()}. Returning home.`);
                returnToHome(); return;
            }
            deductCoins(selectedBetAmount); gamePot = selectedBetAmount * playerCount;
            const currentPlayersCount = playerCount; 
            const bgMusic = document.getElementById('backgroundMusic');
            if (bgMusic && typeof bgMusic.pause === 'function') { bgMusic.pause(); bgMusic.currentTime = 0; }
            
            players = []; turnOrder = []; currentPlayerTurnIndex = 0; currentDiceValue = 0;
            humanPlayerCanMove = false; possibleMovesForHuman = []; extraTurnReason = null; gameActive = false;
            clearInterval(countdownInterval); gameStats = { captures:0, turns:0, sixesRolled:0, playerMoves:[]};

            startGameSetupInternal(currentPlayersCount); 
            document.getElementById('winMessage').style.display = 'none'; document.getElementById('forcedCloseOverlay').style.display = 'none';
            document.getElementById('gamePotDisplay').textContent = gamePot.toLocaleString();
        }
        function resetGameConfirm() { showExitConfirmation('reset'); }
        function playAgain() { // Called from Win screen
             if (playerCoins < selectedBetAmount) {
                alert(`Cannot play again. Not enough coins for bet of ${selectedBetAmount.toLocaleString()}. Returning home.`);
                returnToHome(); return;
            }
            deductCoins(selectedBetAmount); // Pay for new game
            gamePot = selectedBetAmount * playerCount;
            
            const currentPlayersCount = playerCount;
            const bgMusic = document.getElementById('backgroundMusic');
            if (bgMusic && typeof bgMusic.pause === 'function') { bgMusic.pause(); bgMusic.currentTime = 0; }
            
            players = []; turnOrder = []; currentPlayerTurnIndex = 0; currentDiceValue = 0;
            humanPlayerCanMove = false; possibleMovesForHuman = []; extraTurnReason = null; gameActive = false;
            clearInterval(countdownInterval); gameStats = { captures:0, turns:0, sixesRolled:0, playerMoves:[]};

            startGameSetupInternal(currentPlayersCount); 
            document.getElementById('winMessage').style.display = 'none';
            document.getElementById('gamePotDisplay').textContent = gamePot.toLocaleString();
        }

        // --- Confetti ---
        function triggerConfetti() {
            const container = document.getElementById('confettiContainer');
            if(!container) return;
            for (let i = 0; i < 80; i++) { // Create 80 confetti particles
                const confetti = document.createElement('div');
                confetti.classList.add('confetti');
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.animationDuration = (Math.random() * 2 + 3) + 's'; // 3-5 seconds fall
                confetti.style.animationDelay = Math.random() * 0.5 + 's';
                const r = Math.floor(Math.random() * 256);
                const g = Math.floor(Math.random() * 256);
                const b = Math.floor(Math.random() * 256);
                confetti.style.backgroundColor = `rgb(${r},${g},${b})`;
                confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
                container.appendChild(confetti);
                // Remove confetti element after animation to prevent too many elements
                setTimeout(() => { confetti.remove(); }, 5000);
            }
        }

        // --- Initialize Profile & UI on Load ---
        window.onload = () => {
            initPlayerProfile();
            // Ensure other UI event listeners from main game (like close/back buttons) are set initially if needed
            // Or set them when game screen becomes active (done in initLudoGameCore)
        };
    </script>
</body>
</html>
