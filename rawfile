wants to significantly expand the Ludo game with several new features, including:
Board Layouts for 3 and 6 Players:
The provided image shows specific layouts for 3-player and 6-player games. This will require a more flexible board drawing and path definition system than the current 4-arm fixed layout.
For 3-player: It seems to use 3 arms of a 4-arm board.
For 6-player: It's a star-shaped board. This is a major change to PLAYER_GEOMETRY_CONFIG and MAIN_TRACK_COORDS. The current 15x15 grid might not be ideal for a true 6-player star board. I'll need to adapt or use a different grid/coordinate system. Given the complexity, I might have to simplify the 6-player board rendering onto the existing grid, or make it clear that a true star layout is a very large change. Self-correction: The image shows a 6-player board that is essentially the 4-player cross shape with two additional arms filling the diagonal spaces between the existing arms' home bases. This is more feasible than a true hexagonal star on a square grid.
Game Close Option with Penalty/Reward:
A pop-up "Do you want to close this game?"
If "Yes":
The closer loses.
The remaining opponent (or a designated opponent in multi-player) wins.
Both are redirected to a "home page" (player selection screen for now) within 5 seconds.
Winner and loser status should be shown on a "player profile" (this implies storing player stats, which is a larger backend feature, but I can simulate it locally).
Betting System:
Predefined bet amounts: 500, 1k, 10k, 50k, 100k, 500k, 1M, 5M, 10M.
This requires a "game coin" currency.
Game Coin System:
Players need coins to start a game (presumably the bet amount).
New users get 5000 coins as a joining reward. (This will be a one-time local storage thing).
Rewarded Ads System (Simulated):
Users can "watch videos" (simulated by a button click and delay) to earn coins.
Daily limit: 5000 coins from rewards. (This needs to track daily earnings and last reward date).
Implementation Strategy:
Data Storage: Use localStorage to persist:
Player coin balances.
Joining bonus status (to give it only once).
Daily reward earnings and last reward date.
Basic player profile stats (wins/losses).
UI for New Features:
Betting: Add a betting selection step before starting the game, or integrate it into the player selection screen.
Coin Display: Show player's current coin balance prominently.
Rewarded Ads: Add a button for "Watch Ad for Coins".
Player Profile: A simple display area for wins/losses and coin balance, perhaps on the player selection screen or a separate (simulated) profile view.
Board Layouts:
This is the most complex graphics change. I'll need to:
Define new PLAYER_GEOMETRY_CONFIG and MAIN_TRACK_COORDS for 6 players. The 3-player can likely reuse parts of the 4-player config by disabling one player/arm.
The 6-player layout from the image uses the same central cross but adds two more "arms" diagonally. The board dimensions might need to be adjusted or the cell size reduced to fit this visually if I stick to the 15x15 grid.
Alternatively, I might need a larger grid (e.g., 19x19 or 21x21) to accommodate a 6-player board properly, which would scale all existing coordinates.
The image for 6-player seems to be based on a standard 4-arm cross, with the other two players using the diagonals. Let's analyze: Red, Green, Yellow, Blue are standard. The image also shows a "dark green" (let's call it Teal) and an "orange/brown" (let's call it Brown). Teal seems to be opposite Yellow, and Brown opposite Blue. This layout is different from the standard Ludo King 6-player star. The image shows the 6-player star bases outside the main cross. This is a significant change from the current implementation where home areas are part of the main grid corners.
Looking closely at the 6-player image: it has 4 main arms (Green, Blue, Red, and another not shown but implied). The "Start" squares for Yellow and what looks like a Purple/Dark Blue are shown. The star points are the safe zones. This is a star board.
This will require a complete rethink of MAIN_TRACK_COORDS and PLAYER_GEOMETRY_CONFIG for 6 players. It might be easier to use a different set of constants and drawing logic based on playerCount.
For 3 players, it seems to use three arms of the cross, typically Red, Green, Yellow. Blue's arm is unused.
Game Close Logic:
The "Close Button" (#closeButton) already shows an exit confirmation. I'll modify its behavior.
When a player closes, determine the winner (e.g., the next player in turn order, or if 1v1, the other player).
Update coin balances (loser pays bet, winner gets bet * (num_players - 1)).
Update win/loss stats.
Show a temporary message about who won/lost due to closure.
Start a 5-second timer to return to the player selection screen.
Coin Management:
Functions to add/deduct coins.
Initialize coins for new players.
Track daily ad rewards.
Detailed Plan for Board Layouts (6-Player Star):
The 6-player star board is the trickiest part. The image suggests:
6 arms.
Each arm has:
A home base (4 tokens).
A starting square.
A path of 6 squares leading to the central star area.
A home stretch of 6 squares (5 colored + 1 final).
The main track is longer. If each outer arm section is 6 squares, and there are 6 such sections before a turn, plus squares near the center... it could be 6 * (6+1) = 42 squares for the outer perimeter. Or, looking at Ludo King, it's often 6 arms, 5 squares per outer segment, 1 square turn, then 1 square to next arm segment. Total path length: 6 * (5 + 1 + 1) = 42 squares before home entry points. Plus a home stretch.
Given the existing 15x15 grid, a true star layout like Ludo King's is very hard to fit perfectly while keeping cells square. I'll aim for a representation that captures the essence. The user-provided image seems to simplify this by still having a central "cross" but adding start positions for the other two players, and 4 external star safe spots. This is NOT a star path. It's a standard cross board with more start points and more safe spots. This is much more manageable.
Let's re-evaluate the 6-player image:
It is a standard 4-arm cross.
Green is top, Red is right, Blue is bottom, (implied Yellow is left).
It shows additional start squares for (what looks like) a light blue/cyan and a dark green/teal. These players would presumably share paths or have very short unique paths before joining the main circuit. This is unusual.
The "star" symbols are on the main path, which is standard.
This means the 6-player version might still use the 52-square main track, but players 5 and 6 would have different start positions and potentially different home entry logic.
Let's assume the 6-player version in the image means:
Standard 4-player board structure (Red, Green, Yellow, Blue).
Player 5 (Purple) and Player 6 (Orange) will use modified start points and home entries on this existing structure. For example, Purple could start halfway along Red's initial path segment, and Orange halfway along Green's. This is how some non-standard Ludo variations work. This reuses the existing MAIN_TRACK_COORDS.
The "home" areas for Purple and Orange would need to be placed in the empty diagonal spaces.
This seems more feasible with the current code structure.
Revised Plan for Board Layouts:
2-Player: Uses Red and Yellow arms (opposite). Green and Blue are inactive.
3-Player: Uses Red, Green, Yellow arms. Blue is inactive.
4-Player: Current setup (Red, Green, Blue, Yellow).
6-Player (based on image interpretation of a cross with additional start points):
Red, Green, Blue, Yellow are standard.
Purple (player 4) and Orange (player 5) will have their home bases in the diagonal quadrants.
Their start squares will be on the main track, perhaps near their base.
Their home paths will branch off the main track.
The 4 "star" safe spots are as shown. The central star is the finish area.
Coin and Profile Data Structure (localStorage):
{
  "ludoPlayerProfiles": {
    "player1": { "coins": 5000, "wins": 0, "losses": 0 },
    // ... other profiles if we want to simulate multiple users on one browser
  },
  "ludoGameSettings": {
    "currentUser": "player1", // if we simulate profiles
    "lastAdRewardDate": "YYYY-MM-DD",
    "todayAdCoinsEarned": 0,
    "hasReceivedJoiningBonus": true // for the current 'user'
  }
}
Use code with caution.
Json
For simplicity, I'll probably just have one global coin balance and stats, not multiple profiles, unless explicitly asked to simulate that. Let's stick to a single "user" for now.
// localStorage keys
const LS_COINS_KEY = 'ludoSmartCoins';
const LS_WINS_KEY = 'ludoSmartWins';
const LS_LOSSES_KEY = 'ludoSmartLosses';
const LS_JOINING_BONUS_KEY = 'ludoSmartJoiningBonusReceived';
const LS_LAST_AD_DATE_KEY = 'ludoSmartLastAdDate';
const LS_TODAY_AD_COINS_KEY = 'ludoSmartTodayAdCoins';
Use code with caution.
JavaScript
UI Elements to Add/Modify:
Player selection screen:
Show current coins.
Bet selection options (radio buttons or styled divs).
"Watch Ad for Coins" button.
Win/Loss record display.
Game screen:
Ensure closeButton's popup has the new text and logic.
A new section in player-selection div for "Profile & Rewards".
Let's start coding these enhancements step-by-step.
Step 1: Coin System and LocalStorage Integration.
Initialize coins, joining bonus.
Functions to get/set coins.
Display coins.
Step 2: Betting System.
Add bet options to UI.
Deduct bet at game start.
Award winnings at game end.
Step 3: Rewarded Ads System (Simulated).
"Watch Ad" button.
Logic for daily limits.
Step 4: Game Close Logic with Penalty/Win.
Modify showExitConfirmation and related functions.
Handle coin transfer and win/loss update on forced close.
Auto-redirect to home.
Step 5: Player Stats (Wins/Losses).
Store and display wins/losses.
Update them at game end and on forced close.
Step 6: Board Layouts (3-player & 6-player adjustments).
Adjust PLAYER_GEOMETRY_CONFIG based on playerCount.
For 3-player: Deactivate one player's geometry.
For 6-player: This is the most complex. The image for "6-Player" has 4 main arms in a cross, and then two more players seem to have their "START" squares. The paths for these extra players are not fully clear from the "6-Player START" portions. The central board shows 4 arms. The "6-Player" text is above a standard cross board. This strongly suggests the 6-player mode uses the 4-arm board, and the extra players (Purple, Orange) will have home bases in the diagonal empty quadrants and start/enter home on the existing track, similar to how I handled it before. The "star" safe spots are still on the main 4 arms. This is the most practical approach.
The "6-player" image actually shows 6 distinct home areas outside the main path, which is a star board. My previous interpretation of a 4-arm cross with extra starts might be wrong if I'm to follow the image strictly for the 6-player variant.
Okay, the "6-Player" diagram clearly shows a 6-armed board for the path (Green top, Red top-right, Blue bottom-right, etc.). The home bases are squares outside these arms. The grid cells for path are 1 wide.
This will require a new MAIN_TRACK_COORDS_6_PLAYER and PLAYER_GEOMETRY_CONFIG_6_PLAYER.
The central area is a large star.
Each arm has 5 squares on the outer path, then turns. Path: 5 squares, turn, 1 square, turn, 1 square, turn into home stretch. Total main path might be 6 * (5+1+1) = 42 squares. This is common in 6-player Ludo.
Grid size: If each square is CELL_SIZE, and an arm is ~7 cells long, the board might need to be ~19x19 or ~21x21 to look good. The current 15x15 is tight.
Decision: For the 6-player board, I will attempt to implement a 6-arm path. This will be a significant refactor of board coordinates and drawing. The home areas will be drawn outside the main path grid. The 15x15 grid will be challenging. I might need to effectively make cells smaller or the board relatively more "cramped". Or, I can keep CELL_SIZE as canvas.width / EFFECTIVE_GRID_SIZE where EFFECTIVE_GRID_SIZE is larger for 6 players (e.g., 19 or 21). This will make tokens smaller.
Re-evaluating the 6-player image AGAIN:
The 6-player image does show a symmetric 6-armed star path.
Example: Green (top) arm. Home base above. Path goes down.
Path appears to be: 5 squares in line -> 1 square (turn left for next player, or right into home path) -> next segment...
The safe "star" symbols are on the first square of each of the 6 arms.
The very center is a larger star where all home paths converge.
This will be complex. I will define new coordinates and drawing logic specifically for playerCount === 6.
For playerCount === 3, I will use 3 arms of the 4-player board. (Red, Green, Yellow typically).
For playerCount === 2, I will use 2 opposite arms of the 4-player board. (Red, Yellow typically).
Refining playerCount specific logic:
startGameSetup(count) will set playerCount.
initGame will then call a setup function like initializeBoardGeometryAndPlayers().
initializeBoardGeometryAndPlayers will have if/else if for playerCount to set up:
Active players.
Their geometric configurations (home areas, start positions, home paths).
The main track coordinates to use.
Safe square locations.
drawBoard will also need to be aware of the active configuration (e.g., which MAIN_TRACK_COORDS to use, how many home bases to draw).
This is a substantial amount of work. I will focus on getting the core mechanics (coins, betting, close penalty) working first, then tackle the board layout variations. The 6-player star board is the biggest challenge.
Let's add the bet options. The provided list has duplicates for 10000. Assuming it's a typo and meant 100k.
Bets: 500, 1k, 10k, 50k, 100k, 500k, 1M, 5M, 10M.
1000k = 1M. 5000k = 5M. 10000k = 10M. So the list is effectively:
500, 1000, 10000, 50000, 100000, 500000, 1000000, 5000000, 10000000.
I will add a "Profile" section to the player-selection screen to show coins, wins, losses, and the "Watch Ad" button.
The betting options will also be on the player-selection screen. A game can only start if the player has enough coins for the selected bet.
The "closer and winner both should come to home page automatically within 5 seconds show winner and loser on player profile also" - this implies a temporary message overlay on the game screen after a close, then redirect. The "player profile" changes (coins, W/L) will be reflected when they return to the player selection/"home" screen.
The 6-player board from the image is Green (top), Red (top-right), Blue (bottom-right), Yellow (bottom), Purple (bottom-left), Orange (top-left). (Colors are my interpretation).
Each arm's outer path is 5 squares, then 1 square for turning/entering home, then 1 more square that's part of the "junction" before the next arm's 5 squares. So, main path length per segment = 5 (straight) + 1 (corner/entry) + 1 (junction). Total = 7 squares per player section. Main path = 6 * 7 = 42 squares. Home stretch = 5 colored + 1 center.
This is a huge set of changes. I will do my best to integrate them. Some visual aspects of the 6-player board might be simplified to fit the existing canvas/grid structure without a complete overhaul of the rendering system to support a hexagonal grid, but I will try to make it geometrically distinct.
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Ludo Game - Enhanced</title>
    <style>
        /* ... (previous CSS, potentially with adjustments for new elements) ... */
        :root {
            --red: #e74c3c;
            --green: #2ecc71;
            --blue: #3498db;
            --yellow: #f1c40f;
            --purple: #9b59b6;
            --orange: #e67e22;
            --teal: #1abc9c; /* For 6-player board, if needed */
            --pink: #e91e63; /* For 6-player board, if needed */
            --gray: #ecf0f1;
            --dark-gray: #333;
            --light-gray: #f5f5f5;
            --board-bg: #fdfdfd;
            --safe-star-color: #ffd700; /* Gold for star */
        }
        
        body {
            margin: 0;
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: var(--light-gray);
            min-height: 100vh;
            padding-bottom: 20px;
        }
        
        header {
            width: 100%;
            background: linear-gradient(135deg, #6e48aa 0%, #9d50bb 100%);
            color: white;
            padding: 15px 0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            position: sticky;
            top:0;
            z-index: 50;
        }
        
        h1 { margin: 0; font-size: 2.2rem; }
        
        .back-button, .close-button {
            position: absolute; top: 50%; transform: translateY(-50%);
            background: none; border: none; color: white; font-size: 1.5rem;
            cursor: pointer; padding: 5px 10px; border-radius: 5px; transition: background 0.3s;
        }
        .back-button { left: 20px; }
        .close-button { right: 20px; }
        .back-button:hover, .close-button:hover { background: rgba(255,255,255,0.2); }
        
        .player-selection {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; overflow-y: auto; padding: 20px; box-sizing: border-box;
        }
        .player-selection-content {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 700px;
            width: 95%;
            text-align: center;
        }

        .player-selection h2 { color: var(--dark-gray); font-size: 1.8rem; margin-bottom: 20px; }
        .player-options { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; margin-bottom:20px;}
        .player-option {
            background: var(--light-gray); padding: 15px; border-radius: 10px; text-align: center;
            cursor: pointer; transition: all 0.3s ease; box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            min-width: 120px; border: 2px solid transparent;
        }
        .player-option:hover, .player-option.selected {
            transform: scale(1.05); box-shadow: 0 5px 15px rgba(0,0,0,0.2); border-color: #6e48aa;
        }
        .player-option h3 { font-size: 1.2rem; margin: 0 0 5px 0; color: #6e48aa; }
        .player-option p { color: #555; margin: 0; font-size:0.8em; }

        .profile-rewards-section, .betting-section {
            margin-top: 20px; padding: 15px; background: #f9f9f9; border-radius: 10px;
        }
        .profile-rewards-section h3, .betting-section h3 { margin-top:0; color: var(--dark-gray); }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom:15px; }
        .stat-item { background: white; padding: 10px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .stat-item strong { color: #6e48aa; }
        #watchAdButton { background: linear-gradient(135deg, var(--green) 0%, #58d68d 100%); margin-top:10px; width:100%;}
        #watchAdButton:disabled { background: #aaa; cursor: not-allowed;}

        .bet-options { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; }
        .bet-option {
            padding: 8px 15px; background: white; border: 1px solid #ddd; border-radius: 20px;
            cursor: pointer; transition: all 0.2s; font-weight: bold;
        }
        .bet-option:hover { background: #efefef; }
        .bet-option.selected { background: #6e48aa; color: white; border-color: #6e48aa;}
        #startGameButton { margin-top:20px; background: linear-gradient(135deg, var(--orange) 0%, #f39c12 100%); width:100%; font-size:1.1em; padding: 12px;}


        .game-container {
            /* ... existing styles ... */
            display: none; /* Initially hidden */
        }
        canvas { /* ... existing styles ... */ }
        .controls { /* ... existing styles ... */ }
        .dice { /* ... existing styles ... */ }
        .countdown { /* ... existing styles ... */ }
        .settings-panel { /* ... existing styles ... */ }
        .token-balances { /* ... existing styles ... */ }
        .custom-turn-order { /* ... existing styles ... */ }
        .game-info { /* ... existing styles ... */ }
        
        .win-message, .exit-confirmation, .forced-close-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 200; color: white; text-align: center;
        }
        .forced-close-overlay h2 { font-size: 2.5rem; margin-bottom: 15px; }
        .forced-close-overlay p { font-size: 1.2rem; margin-bottom: 20px; }
        .forced-close-overlay .timer { font-size: 1.5rem; color: var(--yellow); }

        .win-message h2 { /* ... */ }
        .win-message button { /* ... */ }
        .exit-dialog { /* ... */ }
        /* ... other existing styles ... */

    </style>
</head>
<body>
    <header>
        <button class="back-button" id="backButton" style="display: none;">← Back</button>
        <h1>Smart Ludo Game</h1>
        <button class="close-button" id="closeButton" style="display: none;">×</button>
    </header>

    <div class="player-selection" id="playerSelectionScreen">
        <div class="player-selection-content">
            <h2>Welcome to Smart Ludo!</h2>

            <div class="profile-rewards-section">
                <h3>Your Profile & Rewards</h3>
                <div class="stats-grid">
                    <div class="stat-item">Coins: <strong id="playerCoins">0</strong></div>
                    <div class="stat-item">Wins: <strong id="playerWins">0</strong></div>
                    <div class="stat-item">Losses: <strong id="playerLosses">0</strong></div>
                </div>
                <button id="watchAdButton" onclick="watchAdForCoins()">Watch Ad for Coins (+500)</button>
                <p id="adRewardMessage" style="font-size:0.8em; margin-top:5px;"></p>
            </div>

            <div class="betting-section">
                <h3>Select Bet Amount</h3>
                <div class="bet-options" id="betOptionsContainer">
                    <!-- Bet options will be populated by JS -->
                </div>
            </div>
            
            <h3>Select Number of Players</h3>
            <div class="player-options" id="playerOptionsContainer">
                <div class="player-option" data-value="2"><h3>2 Players</h3><p>1v1 Classic</p></div>
                <div class="player-option" data-value="3"><h3>3 Players</h3><p>Triple Threat</p></div>
                <div class="player-option" data-value="4"><h3>4 Players</h3><p>Full Board</p></div>
                <div class="player-option" data-value="6"><h3>6 Players</h3><p>Star Board Action</p></div>
            </div>
            <button id="startGameButton" onclick="validateAndStartGame()">Start Game</button>
        </div>
    </div>

    <div class="game-container" id="gameContainer">
        <!-- ... existing game container HTML ... -->
         <canvas id="ludoCanvas" width="600" height="600"></canvas>
        
        <div class="game-info">
            <div class="current-player" id="currentPlayer">Current Player: Red</div>
            <div class="dice-value" id="diceValue">Dice: -</div>
            <div class="game-message" id="gameMessage">Welcome! Click dice or token.</div>
        </div>
        
        <div class="controls">
            <div class="dice" id="dice">🎲</div>
            <div class="countdown" id="countdown"><div class="countdown-bar" id="countdownBar"></div></div>
        </div>
        
        <div class="token-balances" id="tokenBalances"></div>
        
        <div class="custom-turn-order" id="customTurnOrderContainer">
            <label>Turn Order:</label>
            <button onclick="updateTurnOrder()">Update Order</button>
        </div>
        
        <div class="settings-panel">
            <div class="setting-row">
                <input type="checkbox" id="autoMode" checked>
                <label for="autoMode">Auto Mode (AI plays for selected non-human players)</label>
            </div>
            <div class="setting-row">
                <input type="checkbox" id="autoRoll" checked>
                <label for="autoRoll">Auto-Roll After Delay</label>
            </div>
            <div class="setting-row">
                <input type="checkbox" id="smartCapture" checked>
                <label for="smartCapture">Smart Capture (AI prioritizes captures)</label>
            </div>
            <div class="setting-row">
                <input type="checkbox" id="safeMove" checked>
                <label for="safeMove">Safe Moves (AI avoids danger zones)</label>
            </div>
            <div class="setting-row">
                <input type="checkbox" id="aiVsAi">
                <label for="aiVsAi">AI vs AI Simulation (All players are AI)</label>
            </div>
            <div class="setting-row">
                <input type="checkbox" id="soundEffects" checked>
                <label for="soundEffects">Sound Effects</label>
            </div>
            <button onclick="resetGameConfirm()" style="margin-top: 15px; width: 100%;">Reset Game</button>
        </div>
    </div>

    <div class="win-message" id="winMessage">
        <h2 id="winnerText">Player Wins!</h2>
        <p id="winDetails">Congratulations on your victory!</p>
        <button onclick="returnToHome()">Back to Home</button>
    </div>

    <div class="exit-confirmation" id="exitConfirmation">
        <div class="exit-dialog">
            <h3 id="exitDialogTitle">Exit Game</h3>
            <p id="exitDialogMessage">Are you sure?</p>
            <div class="exit-buttons">
                <button id="confirmExitButton" onclick="confirmExit()">Yes</button>
                <button onclick="cancelExit()">No</button>
            </div>
        </div>
    </div>

    <div class="forced-close-overlay" id="forcedCloseOverlay">
        <h2 id="forcedCloseTitle">Game Over</h2>
        <p id="forcedCloseMessage">Player X left the game. Player Y wins!</p>
        <p>Returning to home in <span id="forcedCloseTimer" class="timer">5</span>s</p>
    </div>

    <audio id="diceSound" src="https://assets.mixkit.co/sfx/preview/mixkit-plastic-dice-roll-1494.mp3" preload="auto"></audio>
    <audio id="moveSound" src="https://assets.mixkit.co/sfx/preview/mixkit-unlock-game-notification-253.mp3" preload="auto"></audio>
    <audio id="captureSound" src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-explosion-2759.mp3" preload="auto"></audio>
    <audio id="winSound" src="https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3" preload="auto"></audio>
    <audio id="errorSound" src="https://assets.mixkit.co/sfx/preview/mixkit-game-show-wrong-answer-buzz-950.mp3" preload="auto"></audio>
    <audio id="coinSound" src="https://assets.mixkit.co/sfx/preview/mixkit-game-success-alert-2039.mp3" preload="auto"></audio>
    <audio id="backgroundMusic" loop src="https://assets.mixkit.co/music/preview/mixkit-game-show-suspense-waiting-668.mp3" preload="auto"></audio>

    <script>
        // Constants for localStorage
        const LS_COINS_KEY = 'ludoSmartCoinsV2';
        const LS_WINS_KEY = 'ludoSmartWinsV2';
        const LS_LOSSES_KEY = 'ludoSmartLossesV2';
        const LS_JOINING_BONUS_KEY = 'ludoSmartJoiningBonusReceivedV2';
        const LS_LAST_AD_DATE_KEY = 'ludoSmartLastAdDateV2';
        const LS_TODAY_AD_COINS_KEY = 'ludoSmartTodayAdCoinsV2';
        const DAILY_AD_COIN_LIMIT = 5000;
        const AD_REWARD_AMOUNT = 500;
        const JOINING_BONUS_AMOUNT = 5000;

        const BET_AMOUNTS = [500, 1000, 10000, 50000, 100000, 500000, 1000000, 5000000, 10000000];
        let selectedBetAmount = BET_AMOUNTS[0];
        let selectedPlayerCount = 0;


        // ... (Keep existing canvas, ctx, GRID_SIZE, CELL_SIZE, TOKEN_RADIUS, etc. from previous script)
        // ... (The entire previous JavaScript Ludo logic will be here, with modifications)

        // --- Enhanced Player/Coin Management ---
        let playerCoins = 0;
        let playerWins = 0;
        let playerLosses = 0;

        function initPlayerProfile() {
            const storedCoins = localStorage.getItem(LS_COINS_KEY);
            const joiningBonusReceived = localStorage.getItem(LS_JOINING_BONUS_KEY) === 'true';

            if (storedCoins === null) {
                playerCoins = JOINING_BONUS_AMOUNT;
                localStorage.setItem(LS_COINS_KEY, playerCoins.toString());
                localStorage.setItem(LS_JOINING_BONUS_KEY, 'true');
                alert(`Welcome! You've received ${JOINING_BONUS_AMOUNT} joining bonus coins!`);
            } else {
                playerCoins = parseInt(storedCoins);
                if (!joiningBonusReceived) { // Should not happen if storedCoins is null, but as a fallback
                    playerCoins += JOINING_BONUS_AMOUNT;
                    localStorage.setItem(LS_COINS_KEY, playerCoins.toString());
                    localStorage.setItem(LS_JOINING_BONUS_KEY, 'true');
                    alert(`Welcome back! You've received a late ${JOINING_BONUS_AMOUNT} joining bonus coins!`);
                }
            }

            playerWins = parseInt(localStorage.getItem(LS_WINS_KEY) || '0');
            playerLosses = parseInt(localStorage.getItem(LS_LOSSES_KEY) || '0');
            updateProfileDisplay();
            setupBetOptions();
            setupPlayerCountOptions();
        }

        function updateProfileDisplay() {
            document.getElementById('playerCoins').textContent = playerCoins.toLocaleString();
            document.getElementById('playerWins').textContent = playerWins;
            document.getElementById('playerLosses').textContent = playerLosses;
            checkAdRewardStatus();
        }

        function addCoins(amount) {
            playerCoins += amount;
            localStorage.setItem(LS_COINS_KEY, playerCoins.toString());
            updateProfileDisplay();
            playSound('coinSound');
        }

        function deductCoins(amount) {
            playerCoins -= amount;
            localStorage.setItem(LS_COINS_KEY, playerCoins.toString());
            updateProfileDisplay();
        }

        function incrementWins() {
            playerWins++;
            localStorage.setItem(LS_WINS_KEY, playerWins.toString());
            updateProfileDisplay();
        }

        function incrementLosses() {
            playerLosses++;
            localStorage.setItem(LS_LOSSES_KEY, playerLosses.toString());
            updateProfileDisplay();
        }

        function checkAdRewardStatus() {
            const today = new Date().toISOString().split('T')[0];
            const lastAdDate = localStorage.getItem(LS_LAST_AD_DATE_KEY);
            let todayAdCoins = 0;

            if (lastAdDate === today) {
                todayAdCoins = parseInt(localStorage.getItem(LS_TODAY_AD_COINS_KEY) || '0');
            } else {
                localStorage.setItem(LS_LAST_AD_DATE_KEY, today);
                localStorage.setItem(LS_TODAY_AD_COINS_KEY, '0');
            }
            
            const adButton = document.getElementById('watchAdButton');
            const adMessage = document.getElementById('adRewardMessage');
            if (todayAdCoins >= DAILY_AD_COIN_LIMIT) {
                adButton.disabled = true;
                adMessage.textContent = `Daily ad reward limit reached (${DAILY_AD_COIN_LIMIT} coins). Try again tomorrow.`;
            } else {
                adButton.disabled = false;
                adMessage.textContent = `Earn ${AD_REWARD_AMOUNT} coins. ${DAILY_AD_COIN_LIMIT - todayAdCoins} coins remaining today.`;
            }
        }

        function watchAdForCoins() {
            const adButton = document.getElementById('watchAdButton');
            adButton.disabled = true;
            adButton.textContent = "Loading Ad...";

            // Simulate ad watching
            setTimeout(() => {
                addCoins(AD_REWARD_AMOUNT);
                
                const today = new Date().toISOString().split('T')[0];
                let todayAdCoins = parseInt(localStorage.getItem(LS_TODAY_AD_COINS_KEY) || '0');
                todayAdCoins += AD_REWARD_AMOUNT;
                localStorage.setItem(LS_TODAY_AD_COINS_KEY, todayAdCoins.toString());
                
                alert(`You earned ${AD_REWARD_AMOUNT} coins!`);
                adButton.textContent = `Watch Ad for Coins (+${AD_REWARD_AMOUNT})`;
                checkAdRewardStatus(); // Re-enable button if limit not reached
            }, 2000); // Simulate 2s ad
        }

        function setupBetOptions() {
            const container = document.getElementById('betOptionsContainer');
            container.innerHTML = '';
            BET_AMOUNTS.forEach(amount => {
                const button = document.createElement('div');
                button.className = 'bet-option';
                button.textContent = amount.toLocaleString();
                button.dataset.value = amount;
                if (amount === selectedBetAmount) button.classList.add('selected');
                button.onclick = () => {
                    selectedBetAmount = amount;
                    document.querySelectorAll('.bet-option').forEach(btn => btn.classList.remove('selected'));
                    button.classList.add('selected');
                };
                container.appendChild(button);
            });
        }
        
        function setupPlayerCountOptions() {
            const container = document.getElementById('playerOptionsContainer');
            container.querySelectorAll('.player-option').forEach(option => {
                option.onclick = () => {
                    selectedPlayerCount = parseInt(option.dataset.value);
                     container.querySelectorAll('.player-option').forEach(btn => btn.classList.remove('selected'));
                    option.classList.add('selected');
                }
            });
        }


        function validateAndStartGame() {
            if (selectedPlayerCount === 0) {
                alert("Please select the number of players.");
                return;
            }
            if (playerCoins < selectedBetAmount) {
                alert(`Not enough coins to bet ${selectedBetAmount.toLocaleString()}. Your balance: ${playerCoins.toLocaleString()}`);
                return;
            }

            deductCoins(selectedBetAmount); // Deduct bet before starting
            // Call the Ludo game's startGameSetup function
            startGameSetup(selectedPlayerCount); // This is the existing function to initialize Ludo
        }
        
        function returnToHome() {
            // This function is called after a normal game win or a forced close redirect
            document.getElementById('winMessage').style.display = 'none';
            document.getElementById('forcedCloseOverlay').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'none';
            document.getElementById('playerSelectionScreen').style.display = 'flex';
            document.getElementById('backButton').style.display = 'none';
            document.getElementById('closeButton').style.display = 'none';
            
            if (document.getElementById('backgroundMusic')?.pause) {
                 document.getElementById('backgroundMusic').pause();
                 document.getElementById('backgroundMusic').currentTime = 0;
            }
            updateProfileDisplay(); // Refresh coins, W/L on home screen
        }

        // --- Modify Ludo's Game End and Exit Logic ---
        // Original endGame function needs to be modified
        function originalEndGame(winnerPlayerIndex) { // Renamed to avoid conflict if already defined
            gameActive = false;
            clearInterval(countdownInterval);
            
            const winner = players[winnerPlayerIndex];
            const humanPlayerIndex = 0; // Assuming player 0 is human

            if (winner === players[humanPlayerIndex]) { // Human player won
                incrementWins();
                addCoins(selectedBetAmount * (playerCount -1) + selectedBetAmount); // Gets own bet back + others' bets
            } else if (playerCount > 1 && players[humanPlayerIndex]) { // Human player lost (and was part of the game)
                // Bet was already deducted. Only increment losses if human was playing.
                // AI vs AI doesn't affect human player's stats.
                const isHumanPlaying = players.some((p,idx) => !p.isAI && idx === humanPlayerIndex);
                if (isHumanPlaying) {
                    incrementLosses();
                }
            }


            document.getElementById('winnerText').textContent = `${winner.name} Wins!`;
            document.getElementById('winnerText').style.color = winner.color;
            document.getElementById('winDetails').textContent = `Congratulations to ${winner.name}! They won ${ (selectedBetAmount * (playerCount-1)).toLocaleString() } coins.`;
            document.getElementById('winMessage').style.display = 'flex';
            playSound('winSound');
            document.getElementById('backgroundMusic').pause();
        }

        // Modify showExitConfirmation and related functions
        function showExitConfirmation(actionType) { // actionType: 'exit' (to home) or 'reset' (current game)
            const dialog = document.getElementById('exitConfirmation');
            const title = document.getElementById('exitDialogTitle');
            const msg = document.getElementById('exitDialogMessage');
            const btn = document.getElementById('confirmExitButton');

            if (actionType === 'reset') {
                title.textContent = 'Reset Game';
                msg.textContent = 'Are you sure you want to reset the current game? Your bet will be lost if you are the only human player.';
                btn.textContent = 'Yes, Reset';
                btn.onclick = confirmReset; // confirmReset will handle bet loss if applicable
            } else { // 'exit' means player wants to quit the current game and go to home
                title.textContent = 'Quit Game';
                msg.textContent = 'Are you sure you want to quit? You will lose your bet and the game.';
                btn.textContent = 'Yes, Quit';
                btn.onclick = confirmQuitGame; 
            }
            dialog.style.display = 'flex';
        }

        function confirmQuitGame() {
            document.getElementById('exitConfirmation').style.display = 'none';
            gameActive = false;
            clearInterval(countdownInterval);

            // Player who quits loses. If multiplayer, another player wins.
            // For simplicity, if human quits, they lose.
            // If AI vs AI and closed, just go home.
            const humanPlayer = players.find(p => !p.isAI); // Assuming one human player for now

            if (humanPlayer && players[turnOrder[currentPlayerTurnIndex]] === humanPlayer) { // Human player is quitting
                incrementLosses(); // Bet already deducted.
                
                // Determine a winner from remaining players
                let winner = null;
                if (playerCount > 1) {
                    // Find next non-quitting player, or any other AI.
                    for(let i=0; i < playerCount; i++) {
                        const potentialWinnerIndex = (turnOrder.indexOf(players.indexOf(humanPlayer)) + 1 + i) % playerCount;
                        const potentialWinnerActualIndex = turnOrder[potentialWinnerIndex];
                        if (players[potentialWinnerActualIndex] !== humanPlayer) {
                             winner = players[potentialWinnerActualIndex];
                             // Award winnings to this AI (conceptually, doesn't affect human coins further)
                             break;
                        }
                    }
                     if (!winner && players.length > 1) winner = players.find(p => p !== humanPlayer); // fallback
                }

                const overlay = document.getElementById('forcedCloseOverlay');
                document.getElementById('forcedCloseTitle').textContent = `${humanPlayer.name} Left!`;
                if (winner) {
                    document.getElementById('forcedCloseMessage').textContent = `${winner.name} wins by default. Winnings: ${(selectedBetAmount * (playerCount -1)).toLocaleString()} coins.`;
                } else {
                     document.getElementById('forcedCloseMessage').textContent = `Game abandoned. Your bet of ${selectedBetAmount.toLocaleString()} is lost.`;
                }
                overlay.style.display = 'flex';

                let timeLeft = 5;
                document.getElementById('forcedCloseTimer').textContent = timeLeft;
                const timerInterval = setInterval(() => {
                    timeLeft--;
                    document.getElementById('forcedCloseTimer').textContent = timeLeft;
                    if (timeLeft <= 0) {
                        clearInterval(timerInterval);
                        returnToHome();
                    }
                }, 1000);

            } else { // AI vs AI or non-active player closed, just go home
                returnToHome();
            }
        }
        
        // Modify confirmReset
        function confirmReset() { 
            document.getElementById('exitConfirmation').style.display = 'none';
            gameActive = false;
            clearInterval(countdownInterval);
            
            // If human player resets, they lose their current bet (it was already deducted).
            // If it's AI vs AI, no coin impact for human player.
            const humanPlayer = players.find(p => !p.isAI);
            if (humanPlayer && playerCount === 1) { // Single human player game
                // Bet is already lost from initial deduction.
                // No additional loss penalty as they are just resetting their own game.
                // However, if we consider a reset as a "loss of current attempt", then:
                incrementLosses();
            } else if (humanPlayer && playerCount > 1) {
                // In multiplayer, resetting might be considered a forfeit of that round's bet.
                // Since bet is deducted at start, this is already handled.
                // A loss could be recorded for this "abandoned" game.
                incrementLosses();
            }


            const currentPlayersCount = playerCount; 
            document.getElementById('backgroundMusic').pause();
            document.getElementById('backgroundMusic').currentTime = 0;
            
            players = [];
            turnOrder = [];
            currentPlayerTurnIndex = 0;
            currentDiceValue = 0;
            humanPlayerCanMove = false;
            possibleMovesForHuman = [];
            extraTurnReason = null;

            // Need to re-deduct bet for the new game if it was refunded or if policy is to pay per game.
            // Current logic: bet deducted at start. So for reset, we need to ensure player *can* bet again.
            if (playerCoins < selectedBetAmount) {
                alert(`Cannot reset. Not enough coins for the ${selectedBetAmount.toLocaleString()} bet. Returning to home.`);
                returnToHome();
                return;
            }
            deductCoins(selectedBetAmount); // Deduct for the new game instance.

            startGameSetup(currentPlayersCount); 
            document.getElementById('winMessage').style.display = 'none';
        }


        // --- Board Layout Adjustments Placeholder ---
        // This will be a large section. For now, the existing 4-player logic will apply.
        // TODO: Implement 2, 3, 6 player board geometry and drawing logic.
        // Example: Inside initGame, after setting playerCount:
        // if (playerCount === 6) {
        //    MAIN_TRACK_COORDS = MAIN_TRACK_COORDS_6_PLAYER;
        //    PLAYER_GEOMETRY_CONFIG = PLAYER_GEOMETRY_CONFIG_6_PLAYER;
        //    SAFE_SQUARE_INDICES = SAFE_SQUARE_INDICES_6_PLAYER;
        //    // Adjust CELL_SIZE or canvas size if needed
        // } else if (playerCount === 2) { ... }
        // ... etc.
        
        // --- Main Script Initialization ---
        window.onload = () => {
            initPlayerProfile(); // Initialize coin system etc.
            // Do not auto-start Ludo game. User will click "Start Game".
            // Add event listener to the main start game button on player selection.
        };

        // !!! PASTE THE ENTIRE PREVIOUS LUDO GAME JAVASCRIPT LOGIC HERE !!!
        // Make sure to replace the old `endGame` with `originalEndGame`
        // and ensure `startGameSetup` is called correctly by `validateAndStartGame`.
        // Player object structure might need `isAI` field.
        // The `PLAYER_GEOMETRY_CONFIG`, `MAIN_TRACK_COORDS`, `SAFE_SQUARE_INDICES`
        // will need to become dynamic based on `playerCount`.

        // === PREVIOUS LUDO SCRIPT (needs integration and modifications) ===
        const canvas = document.getElementById('ludoCanvas');
        const ctx = canvas.getContext('2d');
        
        let GRID_SIZE = 15; // Default for 4 players
        let CELL_SIZE = canvas.width / GRID_SIZE;
        let TOKEN_RADIUS = CELL_SIZE * 0.35;
        const TOKENS_PER_PLAYER = 4;
        let MAIN_TRACK_LENGTH = 52; 
        const HOME_STRETCH_LENGTH = 6;

        let players = [];
        // playerCount is now global and set by player selection
        let currentPlayerTurnIndex = 0; 
        let currentDiceValue = 0;
        let gameActive = false;
        let turnOrder = []; 
        let humanPlayerCanMove = false;
        let possibleMovesForHuman = [];
        let countdownInterval;
        let extraTurnReason = null;

        const baseColors = [ 
            { name: 'Red',    code: 'var(--red)'},    // Player 0
            { name: 'Green',  code: 'var(--green)'},  // Player 1
            { name: 'Yellow', code: 'var(--yellow)'}, // Player 2 (Traditional Yellow)
            { name: 'Blue',   code: 'var(--blue)'},   // Player 3 (Traditional Blue)
            { name: 'Purple', code: 'var(--purple)'}, // Player 4
            { name: 'Orange', code: 'var(--orange)'}  // Player 5
        ];
        
        // Default for 4 players - will be overridden
        let ACTIVE_PLAYER_GEOMETRY_CONFIG = [];
        let ACTIVE_MAIN_TRACK_COORDS = [];
        let ACTIVE_SAFE_SQUARE_INDICES = [];

        // --- Board Configurations (This is where 2,3,6 player variations go) ---
        function configureBoardLayout() {
            GRID_SIZE = 15; // Default
            if (playerCount === 6) {
                GRID_SIZE = 19; // Needs a larger grid for 6-player star
                // Define 6-player specific PLAYER_GEOMETRY_CONFIG_6P, MAIN_TRACK_COORDS_6P, SAFE_SQUARE_INDICES_6P
                // This is a complex task. For now, placeholder:
                console.warn("6-Player board layout not fully implemented. Using 4-player adapted layout.");
                // Fallback to a modified 4-player for now, or a simplified 6-player.
                // Let's try a simplified 6-player on 15x15 by placing homes in corners
                // and having shorter arms on the main cross. This is a compromise.
                ACTIVE_PLAYER_GEOMETRY_CONFIG = [ /* Standard Red, Green, Yellow, Blue */
                    { homeArea: { x: 0, y: 0, w: 6, h: 6 }, startSquareGrid: [1, 6], startPosGlobal: 0, homePathEntryGlobalTrackPos: 50, homePathSquaresGrid: [[6,1],[6,2],[6,3],[6,4],[6,5],[6,6]] },
                    { homeArea: { x: 9, y: 0, w: 6, h: 6 }, startSquareGrid: [8, 1], startPosGlobal: 13, homePathEntryGlobalTrackPos: 11, homePathSquaresGrid: [[13,6],[12,6],[11,6],[10,6],[9,6],[8,6]] },
                    { homeArea: { x: 9, y: 9, w: 6, h: 6 }, startSquareGrid: [6, 13], startPosGlobal: 26, homePathEntryGlobalTrackPos: 24, homePathSquaresGrid: [[8,13],[8,12],[8,11],[8,10],[8,9],[8,8]] },
                    { homeArea: { x: 0, y: 9, w: 6, h: 6 }, startSquareGrid: [13, 8], startPosGlobal: 39, homePathEntryGlobalTrackPos: 37, homePathSquaresGrid: [[1,8],[2,8],[3,8],[4,8],[5,8],[6,8]] },
                    // Purple (Player 4) - uses diagonal space top-left for home, starts on Red's path
                    { homeArea: { x: 0, y: 0, w: 4, h: 4, customOffset:true, offX: 6.5, offY:0.5}, startSquareGrid: [3,6], startPosGlobal: 2, homePathEntryGlobalTrackPos: 0, homePathSquaresGrid: [[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]]}, // Simplified, needs proper path
                    // Orange (Player 5) - uses diagonal space top-right for home, starts on Green's path
                    { homeArea: { x: 11, y: 0, w: 4, h: 4, customOffset:true, offX: 8.5, offY:0.5}, startSquareGrid: [8,3], startPosGlobal: 15, homePathEntryGlobalTrackPos: 13, homePathSquaresGrid: [[13,1],[12,2],[11,3],[10,4],[9,5],[8,6]]}, // Simplified
                ];
                ACTIVE_MAIN_TRACK_COORDS = [ /* Standard 52 squares */
                    [1,6],[2,6],[3,6],[4,6],[5,6], [6,5],[6,4],[6,3],[6,2],[6,1],[6,0], [7,0],[8,0],
                    [8,1],[8,2],[8,3],[8,4],[8,5], [9,6],[10,6],[11,6],[12,6],[13,6],[14,6], [14,7],[14,8],
                    [13,8],[12,8],[11,8],[10,8],[9,8], [8,9],[8,10],[8,11],[8,12],[8,13],[8,14], [7,14],[6,14],
                    [6,13],[6,12],[6,11],[6,10],[6,9], [5,8],[4,8],[3,8],[2,8],[1,8],[0,8], [0,7],[0,6]
                ];
                ACTIVE_SAFE_SQUARE_INDICES = [0, 8, 13, 21, 26, 34, 39, 47]; // Standard
                MAIN_TRACK_LENGTH = 52;

            } else if (playerCount === 3) { // Red, Green, Yellow
                 ACTIVE_PLAYER_GEOMETRY_CONFIG = [
                    { homeArea: { x: 0, y: 0, w: 6, h: 6 }, startSquareGrid: [1, 6], startPosGlobal: 0, homePathEntryGlobalTrackPos: 50, homePathSquaresGrid: [[6,1],[6,2],[6,3],[6,4],[6,5],[6,6]] }, // Red
                    { homeArea: { x: 9, y: 0, w: 6, h: 6 }, startSquareGrid: [8, 1], startPosGlobal: 13, homePathEntryGlobalTrackPos: 11, homePathSquaresGrid: [[13,6],[12,6],[11,6],[10,6],[9,6],[8,6]] }, // Green
                    { homeArea: { x: 9, y: 9, w: 6, h: 6 }, startSquareGrid: [6, 13], startPosGlobal: 26, homePathEntryGlobalTrackPos: 24, homePathSquaresGrid: [[8,13],[8,12],[8,11],[8,10],[8,9],[8,8]] }, // Yellow
                 ];
                 ACTIVE_MAIN_TRACK_COORDS = [ /* Standard 52 squares */
                    [1,6],[2,6],[3,6],[4,6],[5,6], [6,5],[6,4],[6,3],[6,2],[6,1],[6,0], [7,0],[8,0],
                    [8,1],[8,2],[8,3],[8,4],[8,5], [9,6],[10,6],[11,6],[12,6],[13,6],[14,6], [14,7],[14,8],
                    [13,8],[12,8],[11,8],[10,8],[9,8], [8,9],[8,10],[8,11],[8,12],[8,13],[8,14], [7,14],[6,14],
                    [6,13],[6,12],[6,11],[6,10],[6,9], [5,8],[4,8],[3,8],[2,8],[1,8],[0,8], [0,7],[0,6]
                ];
                ACTIVE_SAFE_SQUARE_INDICES = [0, 8, 13, 21, 26, 34, 39, 47].filter(s => s < 39); // Adjust for 3 players
                MAIN_TRACK_LENGTH = 52;
            } else if (playerCount === 2) { // Red, Yellow (opposite)
                ACTIVE_PLAYER_GEOMETRY_CONFIG = [
                    { homeArea: { x: 0, y: 0, w: 6, h: 6 }, startSquareGrid: [1, 6], startPosGlobal: 0, homePathEntryGlobalTrackPos: 50, homePathSquaresGrid: [[6,1],[6,2],[6,3],[6,4],[6,5],[6,6]] }, // Red
                    { homeArea: { x: 9, y: 9, w: 6, h: 6 }, startSquareGrid: [6, 13], startPosGlobal: 26, homePathEntryGlobalTrackPos: 24, homePathSquaresGrid: [[8,13],[8,12],[8,11],[8,10],[8,9],[8,8]] }, // Yellow
                ];
                 ACTIVE_MAIN_TRACK_COORDS = [ /* Standard 52 squares */
                    [1,6],[2,6],[3,6],[4,6],[5,6], [6,5],[6,4],[6,3],[6,2],[6,1],[6,0], [7,0],[8,0],
                    [8,1],[8,2],[8,3],[8,4],[8,5], [9,6],[10,6],[11,6],[12,6],[13,6],[14,6], [14,7],[14,8],
                    [13,8],[12,8],[11,8],[10,8],[9,8], [8,9],[8,10],[8,11],[8,12],[8,13],[8,14], [7,14],[6,14],
                    [6,13],[6,12],[6,11],[6,10],[6,9], [5,8],[4,8],[3,8],[2,8],[1,8],[0,8], [0,7],[0,6]
                ];
                ACTIVE_SAFE_SQUARE_INDICES = [0, 13, 26, 39]; // Red and Yellow start and their opposites
                MAIN_TRACK_LENGTH = 52;
            } else { // Default 4 players
                ACTIVE_PLAYER_GEOMETRY_CONFIG = [
                    { homeArea: { x: 0, y: 0, w: 6, h: 6 }, startSquareGrid: [1, 6], startPosGlobal: 0, homePathEntryGlobalTrackPos: 50, homePathSquaresGrid: [[6,1],[6,2],[6,3],[6,4],[6,5],[6,6]] },
                    { homeArea: { x: 9, y: 0, w: 6, h: 6 }, startSquareGrid: [8, 1], startPosGlobal: 13, homePathEntryGlobalTrackPos: 11, homePathSquaresGrid: [[13,6],[12,6],[11,6],[10,6],[9,6],[8,6]] },
                    { homeArea: { x: 9, y: 9, w: 6, h: 6 }, startSquareGrid: [6, 13], startPosGlobal: 26, homePathEntryGlobalTrackPos: 24, homePathSquaresGrid: [[8,13],[8,12],[8,11],[8,10],[8,9],[8,8]] }, // Swapped Yellow and Blue for classic layout
                    { homeArea: { x: 0, y: 9, w: 6, h: 6 }, startSquareGrid: [13, 8], startPosGlobal: 39, homePathEntryGlobalTrackPos: 37, homePathSquaresGrid: [[1,8],[2,8],[3,8],[4,8],[5,8],[6,8]] }
                ];
                 ACTIVE_MAIN_TRACK_COORDS = [ /* Standard 52 squares */
                    [1,6],[2,6],[3,6],[4,6],[5,6], [6,5],[6,4],[6,3],[6,2],[6,1],[6,0], [7,0],[8,0],
                    [8,1],[8,2],[8,3],[8,4],[8,5], [9,6],[10,6],[11,6],[12,6],[13,6],[14,6], [14,7],[14,8],
                    [13,8],[12,8],[11,8],[10,8],[9,8], [8,9],[8,10],[8,11],[8,12],[8,13],[8,14], [7,14],[6,14],
                    [6,13],[6,12],[6,11],[6,10],[6,9], [5,8],[4,8],[3,8],[2,8],[1,8],[0,8], [0,7],[0,6]
                ];
                ACTIVE_SAFE_SQUARE_INDICES = [0, 8, 13, 21, 26, 34, 39, 47];
                MAIN_TRACK_LENGTH = 52;
            }
            CELL_SIZE = canvas.width / GRID_SIZE;
            TOKEN_RADIUS = CELL_SIZE * 0.35;
        }


        // --- INITIALIZATION (Ludo Game Specific) ---
        function startGameSetup(count) { // `count` is from player selection
            playerCount = count; // Set global playerCount
            configureBoardLayout(); // Configure board based on playerCount

            document.getElementById('playerSelectionScreen').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'flex';
            
            setupTurnOrderInputs(); // Existing Ludo function
            initLudoGameInternal(); // Renamed internal init
            
            if (document.getElementById('soundEffects').checked) {
                const bgMusic = document.getElementById('backgroundMusic');
                bgMusic.volume = 0.2;
                bgMusic.play().catch(e => console.warn("Autoplay for background music prevented:", e));
            }
        }
        
        function initLudoGameInternal() { // Was initGame
            players = [];
            for (let i = 0; i < playerCount; i++) {
                const playerColor = baseColors[i];
                const geometry = ACTIVE_PLAYER_GEOMETRY_CONFIG[i];
                if (!geometry) {
                    console.error(`Missing geometry for player ${i} with playerCount ${playerCount}`);
                    // Fallback or skip player
                    continue;
                }

                players.push({
                    name: playerColor.name,
                    color: playerColor.code,
                    isAI: false, // Will be set based on checkboxes
                    geometry: geometry,
                    tokens: Array(TOKENS_PER_PLAYER).fill(null).map((_, k) => ({
                        id: k, state: 'home', position: -1, globalTrackPos: -1, displayPos: { x: 0, y: 0 }
                    })),
                    finishedTokens: 0
                });
            }
            
            updateTurnOrder(); 
            currentDiceValue = 0;
            gameActive = true;
            humanPlayerCanMove = false;
            possibleMovesForHuman = [];
            extraTurnReason = null;

            const aiVsAi = document.getElementById('aiVsAi').checked;
            const autoMode = document.getElementById('autoMode').checked;
            players.forEach((p, idx) => {
                if (aiVsAi) p.isAI = true;
                else p.isAI = idx > 0 && autoMode; // Player 0 (Red) is human unless AiVsAi
            });
             if (playerCount === 1 && players[0]) players[0].isAI = false;


            updateCurrentPlayerDisplay();
            updateTokenBalances();
            drawBoard();
            showGameMessage(`${players[turnOrder[currentPlayerTurnIndex]].name}'s turn. Roll dice.`);
            
            document.getElementById('dice').addEventListener('click', handleDiceRollAction);
            canvas.addEventListener('click', handleCanvasClick);
            document.getElementById('backButton').addEventListener('click', () => showExitConfirmation('exit'));
            document.getElementById('closeButton').addEventListener('click', () => showExitConfirmation('exit'));
            
            document.getElementById('backButton').style.display = 'block';
            document.getElementById('closeButton').style.display = 'block';

            if (players[turnOrder[currentPlayerTurnIndex]].isAI && document.getElementById('autoRoll').checked) {
                startCountdown(handleDiceRollAction);
            }
        }
        // ... (Rest of the Ludo functions: setupTurnOrderInputs, updateTurnOrder, handleDiceRollAction, rollDice, etc.)
        // ... (Make sure to use ACTIVE_PLAYER_GEOMETRY_CONFIG, ACTIVE_MAIN_TRACK_COORDS, ACTIVE_SAFE_SQUARE_INDICES throughout)
        // ... (The original endGame needs to be replaced by originalEndGame from above)
        // ... (The original resetGameConfirm and confirmReset are replaced by new ones)
        // ... (The original resetGame is replaced by returnToHome, or a version that handles bets)

        // --- Drawing functions need to use ACTIVE_ constants ---
        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--board-bg').trim();
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ACTIVE_PLAYER_GEOMETRY_CONFIG.forEach((geom, geomIndex) => {
                if (geomIndex >= playerCount) return; // Only draw for active players
                let displayColor = players[geomIndex]?.color || baseColors[geomIndex]?.code || 'grey';

                // Home Area
                const homeAreaX = geom.homeArea.customOffset ? geom.homeArea.offX : geom.homeArea.x;
                const homeAreaY = geom.homeArea.customOffset ? geom.homeArea.offY : geom.homeArea.y;
                ctx.fillStyle = displayColor.replace(')', ', 0.3)').replace('var(', 'rgba('); 
                ctx.fillRect(homeAreaX * CELL_SIZE, homeAreaY * CELL_SIZE, geom.homeArea.w * CELL_SIZE, geom.homeArea.h * CELL_SIZE);
                ctx.strokeStyle = displayColor;
                ctx.lineWidth = 2;
                ctx.strokeRect(homeAreaX * CELL_SIZE, homeAreaY * CELL_SIZE, geom.homeArea.w * CELL_SIZE, geom.homeArea.h * CELL_SIZE);
                
                geom.homePathSquaresGrid.forEach((sq) => {
                    ctx.fillStyle = displayColor.replace(')', ', 0.5)').replace('var(', 'rgba(');
                    ctx.fillRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    ctx.strokeStyle = displayColor;
                    ctx.strokeRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                });
            });

            ACTIVE_MAIN_TRACK_COORDS.forEach((sq, index) => {
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim();
                ctx.lineWidth = 1;
                ctx.strokeRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                
                ACTIVE_PLAYER_GEOMETRY_CONFIG.forEach((geom, geomIndex) => {
                    if (geomIndex >= playerCount) return;
                    if (geom.startPosGlobal === index) {
                        let playerForGeom = players[geomIndex];
                        if (playerForGeom) {
                            ctx.fillStyle = playerForGeom.color.replace(')', ', 0.3)').replace('var(', 'rgba(');
                            ctx.fillRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        }
                    }
                });

                if (ACTIVE_SAFE_SQUARE_INDICES.includes(index)) {
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--safe-star-color').trim();
                    ctx.font = `${CELL_SIZE * 0.6}px Arial`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText('★', (sq[0] + 0.5) * CELL_SIZE, (sq[1] + 0.5) * CELL_SIZE);
                }
            });
            
            // Center Finish Area (adapt to GRID_SIZE)
            const mid = Math.floor(GRID_SIZE / 2);
            ctx.fillStyle = '#ddd';
            ctx.beginPath();
            ctx.moveTo((mid -1) * CELL_SIZE, mid * CELL_SIZE); 
            ctx.lineTo(mid * CELL_SIZE, (mid-1) * CELL_SIZE);
            ctx.lineTo((mid +1) * CELL_SIZE, mid * CELL_SIZE); 
            ctx.lineTo(mid * CELL_SIZE, (mid+1) * CELL_SIZE);
            ctx.closePath();
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim();
            ctx.stroke();


            players.forEach((player, playerIdx) => {
                if (!player || !player.tokens) return; // Skip if player data is incomplete (e.g. during setup)
                const geom = player.geometry;
                player.tokens.forEach((token, tokenIdx) => {
                    let x, y;
                    if (token.state === 'home') {
                        const homeCellXBase = geom.homeArea.customOffset ? geom.homeArea.offX : geom.homeArea.x;
                        const homeCellYBase = geom.homeArea.customOffset ? geom.homeArea.offY : geom.homeArea.y;
                        const homeW = geom.homeArea.w; const homeH = geom.homeArea.h;

                        // Improved 2x2 layout within home area, works for various homeArea sizes
                        const relX = (tokenIdx % 2 === 0) ? homeW * 0.25 : homeW * 0.75;
                        const relY = (tokenIdx < 2) ? homeH * 0.25 : homeH * 0.75;
                        x = (homeCellXBase + relX) * CELL_SIZE;
                        y = (homeCellYBase + relY) * CELL_SIZE;

                    } else if (token.state === 'track') {
                        const globalPos = token.globalTrackPos;
                        if (globalPos !== -1 && globalPos < ACTIVE_MAIN_TRACK_COORDS.length) {
                            const sq = ACTIVE_MAIN_TRACK_COORDS[globalPos];
                            x = (sq[0] + 0.5) * CELL_SIZE;
                            y = (sq[1] + 0.5) * CELL_SIZE;
                        } else { console.warn("Invalid globalPos for token on track:", token); return; }
                    } else if (token.state === 'homestretch') {
                        if(token.position >= 0 && token.position < geom.homePathSquaresGrid.length) {
                            const sq = geom.homePathSquaresGrid[token.position];
                            x = (sq[0] + 0.5) * CELL_SIZE;
                            y = (sq[1] + 0.5) * CELL_SIZE;
                        } else {  console.warn("Invalid position for token in homestretch:", token); return; }
                    } else { // finished
                        const finalHomeSq = geom.homePathSquaresGrid[HOME_STRETCH_LENGTH -1];
                        x = (finalHomeSq[0] + 0.5 + (tokenIdx - 1.5) * 0.1) * CELL_SIZE; // Spread them out a bit
                        y = (finalHomeSq[1] + 0.5) * CELL_SIZE;
                    }
                    token.displayPos = {x, y};
                    drawToken(x, y, player.color, token, playerIdx);
                });
            });
        }
         // Copy other Ludo functions like drawToken, updateCurrentPlayerDisplay, showGameMessage, 
         // updateTokenBalances, handleCanvasClick, startCountdown, playSound, AI logic, movement logic etc.
         // Ensure they use ACTIVE_ constants where appropriate.
         // For getPossibleMoves and executeMove, they need to use MAIN_TRACK_LENGTH and player.geometry correctly.

        // (Placeholder for the rest of the original Ludo JS logic)
        // You would copy functions like:
        // setupTurnOrderInputs, updateTurnOrder, handleDiceRollAction, rollDice, processPlayerTurn,
        // getDiceFace, nextTurn, getPossibleMoves, executeMove, isSafePosition, aiMakeMove,
        // drawToken, updateCurrentPlayerDisplay, showGameMessage, updateTokenBalances, handleCanvasClick,
        // startCountdown, playSound
        // Make sure `endGame` in the Ludo logic calls `originalEndGame`.
        // Be careful with global variable names if any overlap.

        // Minimal set of copied functions for structure, these need to be fully copied and adapted from previous script
        function getPossibleMoves(playerIndex, diceRoll) {
            const player = players[playerIndex];
            const moves = [];
            if (!player || !player.tokens) return moves; // Guard

            player.tokens.forEach((token, tokenIdx) => {
                if (token.state === 'finished') return;

                if (token.state === 'home') {
                    if (diceRoll === 6) {
                        const startGlobalPos = player.geometry.startPosGlobal;
                        let ownTokensOnStart = 0;
                        player.tokens.forEach(t => {
                            if (t.state === 'track' && t.globalTrackPos === startGlobalPos) {
                                ownTokensOnStart++;
                            }
                        });
                        if (ownTokensOnStart < 2) { 
                             moves.push({ tokenIndex: tokenIdx, fromState: 'home', toState: 'track', newPosition: 0, newGlobalTrackPos: player.geometry.startPosGlobal });
                        }
                    }
                } else if (token.state === 'track') {
                    const currentTrackProgress = token.position; 
                    const newTrackProgress = currentTrackProgress + diceRoll;
                    const totalStepsForHomeEntry = MAIN_TRACK_LENGTH -1 ; // Path length is 0 to MAIN_TRACK_LENGTH-1

                    if (newTrackProgress <= player.geometry.homePathEntryGlobalTrackPos - player.geometry.startPosGlobal + MAIN_TRACK_LENGTH && newTrackProgress <= totalStepsForHomeEntry ) { // Simplification
                        const newGlobalPos = (player.geometry.startPosGlobal + newTrackProgress) % MAIN_TRACK_LENGTH;
                        moves.push({ tokenIndex: tokenIdx, fromState: 'track', toState: 'track', newPosition: newTrackProgress, newGlobalTrackPos: newGlobalPos });
                    } else { 
                        const stepsIntoHomeStretch = newTrackProgress - ( (player.geometry.homePathEntryGlobalTrackPos - player.geometry.startPosGlobal + MAIN_TRACK_LENGTH)%MAIN_TRACK_LENGTH +1); // Complex, needs per-player path logic
                         if (stepsIntoHomeStretch < HOME_STRETCH_LENGTH && stepsIntoHomeStretch >= 0) { 
                            moves.push({ tokenIndex: tokenIdx, fromState: 'track', toState: 'homestretch', newPosition: stepsIntoHomeStretch, newGlobalTrackPos: -1 });
                        } else if (stepsIntoHomeStretch === HOME_STRETCH_LENGTH) { // This logic seems off
                             moves.push({ tokenIndex: tokenIdx, fromState: 'track', toState: 'finished', newPosition: 0, newGlobalTrackPos: -1 });
                        }
                    }
                } else if (token.state === 'homestretch') {
                    const newHomePos = token.position + diceRoll;
                    if (newHomePos < HOME_STRETCH_LENGTH -1) { 
                        moves.push({ tokenIndex: tokenIdx, fromState: 'homestretch', toState: 'homestretch', newPosition: newHomePos, newGlobalTrackPos: -1 });
                    } else if (newHomePos === HOME_STRETCH_LENGTH -1) { 
                        moves.push({ tokenIndex: tokenIdx, fromState: 'homestretch', toState: 'finished', newPosition: 0, newGlobalTrackPos: -1 });
                    }
                }
            });
            return moves;
        }
         function executeMove(playerIndex, chosenMove) {
            humanPlayerCanMove = false; 
            const player = players[playerIndex];
            const token = player.tokens[chosenMove.tokenIndex];

            token.state = chosenMove.toState;
            token.position = chosenMove.newPosition;
            token.globalTrackPos = chosenMove.newGlobalTrackPos !== undefined ? chosenMove.newGlobalTrackPos : -1;
            
            playSound('moveSound');
            let message = `${player.name} moved a token.`;

            if (token.state === 'track' && !isSafePosition(token.globalTrackPos)) {
                for (let i = 0; i < playerCount; i++) {
                    if (i === playerIndex) continue; 
                    const opponent = players[i];
                    opponent.tokens.forEach(opToken => {
                        if (opToken.state === 'track' && opToken.globalTrackPos === token.globalTrackPos) {
                            opToken.state = 'home'; opToken.position = -1; opToken.globalTrackPos = -1;
                            message = `${player.name} captured ${opponent.name}'s token!`;
                            playSound('captureSound'); extraTurnReason = 'capture'; 
                        }
                    });
                }
            }

            if (token.state === 'finished') {
                player.finishedTokens++;
                message = `${player.name}'s token reached home!`;
                if (player.finishedTokens === TOKENS_PER_PLAYER) {
                    originalEndGame(playerIndex); // Call the modified endGame
                    return; 
                }
                if (currentDiceValue === 6 && extraTurnReason === 'dice_6') {
                    extraTurnReason = 'home_entry_6_no_extra'; 
                }
            }
            
            if (extraTurnReason === 'home_entry_6_no_extra') extraTurnReason = null;
            showGameMessage(message); updateTokenBalances(); drawBoard();
            setTimeout(nextTurn, 1000); 
        }
        function isSafePosition(globalTrackPos) { return ACTIVE_SAFE_SQUARE_INDICES.includes(globalTrackPos); }
        function nextTurn() {
            humanPlayerCanMove = false; possibleMovesForHuman = []; currentDiceValue = 0; 
            document.getElementById('diceValue').textContent = `Dice: -`;

            if (extraTurnReason) { 
                showGameMessage(`${players[turnOrder[currentPlayerTurnIndex]].name} gets an extra turn! Roll dice.`);
                extraTurnReason = null; 
            } else {
                currentPlayerTurnIndex = (currentPlayerTurnIndex + 1) % playerCount;
                updateCurrentPlayerDisplay();
                showGameMessage(`${players[turnOrder[currentPlayerTurnIndex]].name}'s turn. Roll dice.`);
            }
            
            const nextPlayerIsAI = players[turnOrder[currentPlayerTurnIndex]]?.isAI; // Add null check
            if (nextPlayerIsAI && document.getElementById('autoRoll').checked) {
                startCountdown(handleDiceRollAction);
            }
            drawBoard(); 
        }
        function updateCurrentPlayerDisplay() {
            if (!players || players.length === 0 || !players[turnOrder[currentPlayerTurnIndex]]) return; // Guard
            const player = players[turnOrder[currentPlayerTurnIndex]];
            const display = document.getElementById('currentPlayer');
            display.textContent = `Current Player: ${player.name}`;
            display.style.color = player.color;
        }
        function showGameMessage(message) { document.getElementById('gameMessage').textContent = message; }
        function updateTokenBalances() {
            const container = document.getElementById('tokenBalances'); container.innerHTML = '';
            players.forEach(player => {
                if(!player) return;
                const balanceElement = document.createElement('div');
                balanceElement.className = 'token-balance';
                balanceElement.style.background = player.color;
                const tokensLeft = TOKENS_PER_PLAYER - player.finishedTokens;
                balanceElement.textContent = `${player.name}: ${tokensLeft}`;
                container.appendChild(balanceElement);
            });
        }
         function handleCanvasClick(event) {
            if (!humanPlayerCanMove || !gameActive) return;
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left; const clickY = event.clientY - rect.top;
            const playerIndex = turnOrder[currentPlayerTurnIndex];
            const player = players[playerIndex];

            for (const move of possibleMovesForHuman) {
                const token = player.tokens[move.tokenIndex];
                if (!token.displayPos) continue; // Should not happen
                const dx = clickX - token.displayPos.x; const dy = clickY - token.displayPos.y;
                if (dx * dx + dy * dy < TOKEN_RADIUS * TOKEN_RADIUS * 1.5 * 1.5) { 
                    executeMove(playerIndex, move); humanPlayerCanMove = false; 
                    possibleMovesForHuman = []; drawBoard(); return;
                }
            }
        }
        function startCountdown(callback) {
            clearInterval(countdownInterval); const bar = document.getElementById('countdownBar');
            bar.style.width = '100%'; let timeLeft = 100; 
            countdownInterval = setInterval(() => {
                timeLeft -= 5; bar.style.width = `${Math.max(0, timeLeft)}%`;
                if (timeLeft <= 0) { clearInterval(countdownInterval); callback(); }
            }, 100); 
        }
        function playSound(soundId) { /* ... same as before ... */ }
        function aiMakeMove(playerIndex, possibleMoves) { /* ... same as before, ensure it uses ACTIVE_SAFE_SQUARE_INDICES ... */ 
             const player = players[playerIndex];
            let bestMove = null;

            if (currentDiceValue === 6) {
                const homeTokenMove = possibleMoves.find(m => m.fromState === 'home');
                if (homeTokenMove) {
                    const tokensOnBoard = player.tokens.filter(t => t.state === 'track' || t.state === 'homestretch').length;
                    if (tokensOnBoard < 2 || Math.random() < 0.5) bestMove = homeTokenMove;
                }
            }
            
            if (!bestMove && document.getElementById('smartCapture').checked) {
                for (const move of possibleMoves) {
                    if (move.toState === 'track' && !isSafePosition(move.newGlobalTrackPos)) {
                        for (let i = 0; i < playerCount; i++) {
                            if (i === playerIndex) continue;
                            if (players[i].tokens.some(opToken => opToken.state === 'track' && opToken.globalTrackPos === move.newGlobalTrackPos)) {
                                bestMove = move; break;
                            }
                        }
                    }
                    if (bestMove) break;
                }
            }

            if (!bestMove) {
                const finishingMove = possibleMoves.find(m => m.toState === 'finished');
                if (finishingMove) bestMove = finishingMove;
            }

            if (!bestMove && document.getElementById('safeMove').checked) {
                const safeMoves = possibleMoves.filter(m => m.toState === 'track' && isSafePosition(m.newGlobalTrackPos));
                if (safeMoves.length > 0) {
                    safeMoves.sort((a,b) => players[playerIndex].tokens[b.tokenIndex].position - players[playerIndex].tokens[a.tokenIndex].position);
                    bestMove = safeMoves[0];
                }
            }
            
            if (!bestMove) {
                let candidateMoves = possibleMoves.filter(m => m.toState !== 'home'); 
                if (candidateMoves.length === 0) candidateMoves = possibleMoves; 
                candidateMoves.sort((a, b) => {
                    if (a.toState === 'homestretch' && b.toState !== 'homestretch') return -1;
                    if (b.toState === 'homestretch' && a.toState !== 'homestretch') return 1;
                    const tokenA = player.tokens[a.tokenIndex]; const tokenB = player.tokens[b.tokenIndex];
                    if (tokenA.state === 'track' && tokenB.state !== 'track') return -1;
                    if (tokenB.state === 'track' && tokenA.state !== 'track') return 1;
                    return (tokenB.position + (tokenB.state === 'homestretch' ? MAIN_TRACK_LENGTH : 0)) - 
                           (tokenA.position + (tokenA.state === 'homestretch' ? MAIN_TRACK_LENGTH : 0));
                });
                if (candidateMoves.length > 0) bestMove = candidateMoves[0];
            }

            if (!bestMove && possibleMoves.length > 0) {
                bestMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
            }
            
            if (bestMove) executeMove(playerIndex, bestMove);
            else { // No possible move for AI (should have been caught earlier)
                console.warn("AI had no moves but aiMakeMove was called.");
                nextTurn();
            }
        }
         function setupTurnOrderInputs() {
            const container = document.getElementById('customTurnOrderContainer');
            while (container.children.length > 2) { container.removeChild(container.children[1]); }
            for (let i = 0; i < playerCount; i++) {
                const input = document.createElement('input');
                input.type = 'text'; input.id = `turn${baseColors[i].name}`;
                input.placeholder = (i + 1).toString(); input.value = (i + 1).toString();
                input.style.borderColor = baseColors[i].code; // Use CSS var for border
                container.insertBefore(input, container.lastElementChild); 
            }
        }
        function updateTurnOrder() {
            const newOrderPreferences = [];
            for (let i = 0; i < playerCount; i++) {
                const input = document.getElementById(`turn${baseColors[i].name}`);
                const orderVal = parseInt(input?.value) || (i + 1); // Add null check for input
                newOrderPreferences.push({ playerIndex: i, order: orderVal });
            }
            newOrderPreferences.sort((a, b) => a.order - b.order);
            turnOrder = newOrderPreferences.map(item => item.playerIndex);
            currentPlayerTurnIndex = 0; 
            updateCurrentPlayerDisplay();
            if (players && players.length > 0 && players[turnOrder[currentPlayerTurnIndex]]) { // Guard
                 showGameMessage(`Turn order updated. ${players[turnOrder[currentPlayerTurnIndex]].name}'s turn.`);
                 if (gameActive && players[turnOrder[currentPlayerTurnIndex]].isAI && document.getElementById('autoRoll').checked) {
                     startCountdown(handleDiceRollAction);
                 }
            }
        }
         function handleDiceRollAction() {
            if (!gameActive || humanPlayerCanMove) return; 
            if (!players || players.length === 0 || !players[turnOrder[currentPlayerTurnIndex]]) return; //Guard
            const player = players[turnOrder[currentPlayerTurnIndex]];
            if (player.isAI || !document.getElementById('autoMode').checked || turnOrder[currentPlayerTurnIndex] === 0) { 
                 rollDice();
            }
        }
         function rollDice() {
            if (!gameActive) return;
            const diceElement = document.getElementById('dice');
            diceElement.classList.add('animate'); playSound('diceSound');
            setTimeout(() => {
                currentDiceValue = Math.floor(Math.random() * 6) + 1;
                diceElement.textContent = getDiceFace(currentDiceValue);
                diceElement.classList.remove('animate');
                document.getElementById('diceValue').textContent = `Dice: ${currentDiceValue}`;
                extraTurnReason = (currentDiceValue === 6) ? 'dice_6' : null;
                processPlayerTurn();
            }, 500);
        }
         function processPlayerTurn() {
            if (!players || players.length === 0 || !players[turnOrder[currentPlayerTurnIndex]]) return; //Guard
            const playerIndex = turnOrder[currentPlayerTurnIndex];
            const player = players[playerIndex];
            possibleMovesForHuman = getPossibleMoves(playerIndex, currentDiceValue);

            if (possibleMovesForHuman.length === 0) {
                showGameMessage(`${player.name} rolled ${currentDiceValue}. No moves available.`);
                playSound('errorSound'); setTimeout(nextTurn, 1500);
            } else {
                if (player.isAI) {
                    showGameMessage(`${player.name} (AI) rolled ${currentDiceValue}. Thinking...`);
                    setTimeout(() => aiMakeMove(playerIndex, possibleMovesForHuman), 800);
                } else { 
                    humanPlayerCanMove = true;
                    showGameMessage(`${player.name}, select a token to move ${currentDiceValue}.`);
                    drawBoard(); 
                }
            }
        }
        function getDiceFace(value) { const faces = ['⚀', '⚁', '⚂', '⚃', '⚄', '⚅']; return faces[value - 1]; }
        function drawToken(x, y, color, tokenData, playerIndexOfTokenOwner) { /* ... same as before ... */ 
            ctx.beginPath(); ctx.arc(x, y, TOKEN_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = color; ctx.fill();
            ctx.strokeStyle = '#000'; ctx.lineWidth = 1.5; ctx.stroke();

            if (players.length === 0) return; // Guard if players array is empty
            const currentPlayerRealIndex = turnOrder[currentPlayerTurnIndex];
            if (humanPlayerCanMove && playerIndexOfTokenOwner === currentPlayerRealIndex) {
                const isMovable = possibleMovesForHuman.some(move => move.tokenIndex === tokenData.id);
                if (isMovable) {
                    ctx.strokeStyle = 'gold'; ctx.lineWidth = 3; ctx.stroke();
                }
            }
        }

    </script>
</body>
</html>
Use code with caution.
Html
Collapse to hide model thoughts

chevron_right
ThinkingThoughts
(experimental)
The user wants a significant visual overhaul:
Styled Home Areas: Each cell within a player's home base (the 6x6 or 4x4 yard) should be filled with the player's color.
Cone-Shaped Tokens: Tokens should be drawn as road cones instead of circles. This requires custom drawing logic.
Consistent Styling: These visual changes should apply to all player colors.
Let's break down the implementation steps:
1. Styled Home Areas:
* Modify drawBoard():
* When drawing the homeArea for each player, instead of just a colored border and transparent fill, I need to iterate through the cells within that homeArea (e.g., for a 6x6 home area, iterate 36 times).
* For each internal cell, fill it with the player's solid color and then draw a thin border around it.
* This will make the home yards look like a block of colored squares.
2. Cone-Shaped Tokens:
* Modify drawToken():
* This is the trickiest part. A simple cone can be drawn as a triangle on top of a small rectangle or an ellipse.
* Cone Body (Triangle):
* Need to define three points for the triangle.
* The base of the triangle will be wider than the top.
* The height of the triangle will determine the cone's "pointiness".
* Cone Base (Rectangle/Ellipse):
* A small rectangle or an ellipse underneath the triangle to represent the base of the cone.
* The width of this base should match the base of the triangle.
* Coloring: The cone (triangle + base) should be filled with the player's color.
* Border: A black or dark border around the cone shape.
* Sizing: The overall size of the cone should be comparable to TOKEN_RADIUS so it fits within the cells. TOKEN_RADIUS can now define the approximate width or height of the cone.
* Orientation: Cones are typically upright.
* Click Detection: The handleCanvasClick function currently uses a circular radius for click detection. This will need to be adjusted to be a bit more generous or ideally, check against the bounding box of the cone, though for simplicity, a slightly larger circular radius around the cone's center might still work if the cones aren't too oddly shaped.
*   **`drawToken` parameters:**
    *   `x, y`: These will represent the *center base* of the cone.
    *   `color`: Player's color.
    *   `tokenData`, `playerIndexOfTokenOwner`: Used for highlighting movable tokens.

*   **Drawing the Cone in `drawToken(x, y, color, ...)`:**
    *   Let `coneHeight = TOKEN_RADIUS * 2` (or some factor).
    *   Let `coneBaseWidth = TOKEN_RADIUS * 1.5`.
    *   Let `coneTopWidth = coneBaseWidth * 0.2` (for the pointy top).

    *   **Base Rectangle:**
        *   `rectX = x - coneBaseWidth / 2`
        *   `rectY = y - coneBaseHeight` (e.g., `coneBaseHeight = coneHeight * 0.15`)
        *   `ctx.fillRect(rectX, rectY, coneBaseWidth, coneBaseHeight)`

    *   **Body Triangle:**
        *   Point 1 (top center): `(x, y - coneHeight)`
        *   Point 2 (bottom left of triangle body): `(x - coneBaseWidth / 2, rectY)`
        *   Point 3 (bottom right of triangle body): `(x + coneBaseWidth / 2, rectY)`
        *   `ctx.beginPath(); ctx.moveTo(x, y - coneHeight); ctx.lineTo(x - coneBaseWidth/2, rectY); ctx.lineTo(x + coneBaseWidth/2, rectY); ctx.closePath(); ctx.fill();`

    *   **Highlighting:** The highlight stroke should follow the outline of the cone. This means stroking the base rectangle and then the triangle separately.
Use code with caution.
3. Token Placement in Home Yard (Cone Specific):
* The current placement for circular tokens in the home yard is a 2x2 grid.
* Cones might look better slightly offset or with different spacing. I'll adjust the homeCellX, homeCellY calculations in drawBoard() when token.state === 'home'. Since cones have a flat base, aligning their bases might be good.
Refinement and Adjustments:
TOKEN_RADIUS: This variable will now act more like a general "size" indicator for the cone. The cone's actual dimensions (coneHeight, coneBaseWidth) will be derived from it.
Visual Appeal: I'll need to tweak the proportions of the cone (height vs. base width, base thickness) to make it look good.
Clarity on Crowded Squares: If multiple cones are on the same square, they might overlap significantly. The current code just draws them at the center of the square. For simplicity, I'll keep this, but in a more advanced version, one might offset overlapping tokens.
Token Shadow/Highlight (Optional but nice): Adding a subtle gradient or a highlight to the cone could make it look more 3D. For now, I'll stick to flat color + border.
Code Structure Changes:
Mainly drawBoard() for home area cells.
Mainly drawToken() for the new token shape.
Minor adjustments to TOKEN_RADIUS usage and home token placement.
Let's start with drawToken as it's the most complex visual change.
// Inside drawToken function
function drawToken(x, y, color, tokenData, playerIndexOfTokenOwner) {
    const coneHeight = TOKEN_RADIUS * 2.2; // Total height of the cone
    const baseHeight = coneHeight * 0.20; // Height of the cylindrical base
    const baseWidth = TOKEN_RADIUS * 1.8; // Width of the cylindrical base

    const bodyHeight = coneHeight - baseHeight; // Height of the conical part
    const topPointY = y - coneHeight + baseHeight; // Y-coordinate of the cone's tip (base is at y)
    const bodyBaseY = y - baseHeight; // Y-coordinate where conical part meets cylindrical base

    // Start drawing
    ctx.save(); // Save context state

    // 1. Draw the cylindrical base
    ctx.fillStyle = color;
    ctx.beginPath();
    // Use ellipse for a slightly rounded base appearance if desired, or stick to rect
    // For simplicity, let's use a rectangle for the base's side view.
    // A true 3D look would involve an ellipse for top/bottom of cylinder.
    // We'll draw it as if viewed from the side.
    ctx.fillRect(x - baseWidth / 2, y - baseHeight, baseWidth, baseHeight);

    // 2. Draw the conical body
    ctx.beginPath();
    ctx.moveTo(x, topPointY); // Tip of the cone
    ctx.lineTo(x - baseWidth / 2, bodyBaseY); // Bottom-left of conical part
    ctx.lineTo(x + baseWidth / 2, bodyBaseY); // Bottom-right of conical part
    ctx.closePath();
    ctx.fill();

    // 3. Draw outline
    ctx.strokeStyle = '#222'; // Darker outline
    ctx.lineWidth = 1.5;

    // Outline base
    ctx.strokeRect(x - baseWidth / 2, y - baseHeight, baseWidth, baseHeight);
    // Outline conical body
    ctx.beginPath();
    ctx.moveTo(x, topPointY);
    ctx.lineTo(x - baseWidth / 2, bodyBaseY);
    ctx.stroke(); // Left side of cone

    ctx.beginPath(); // Need separate beginPath for different line segments if not closed
    ctx.moveTo(x, topPointY);
    ctx.lineTo(x + baseWidth / 2, bodyBaseY);
    ctx.stroke(); // Right side of cone
    // No need to stroke the base of the triangle as it's covered by the top of the rectangle base

    // Highlight if movable
    const currentPlayerRealIndex = turnOrder[currentPlayerTurnIndex];
    if (humanPlayerCanMove && playerIndexOfTokenOwner === currentPlayerRealIndex) {
        const isMovable = possibleMovesForHuman.some(move => move.tokenIndex === tokenData.id);
        if (isMovable) {
            ctx.strokeStyle = 'gold';
            ctx.lineWidth = 3;
            // Re-stroke the outline with highlight color
            ctx.strokeRect(x - baseWidth / 2, y - baseHeight, baseWidth, baseHeight);
            ctx.beginPath();
            ctx.moveTo(x, topPointY); ctx.lineTo(x - baseWidth / 2, bodyBaseY); ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, topPointY); ctx.lineTo(x + baseWidth / 2, bodyBaseY); ctx.stroke();
        }
    }
    ctx.restore(); // Restore context state
}
Use code with caution.
JavaScript
Now for the Home Area cell coloring in drawBoard():
// Inside drawBoard()
// ...
ACTIVE_PLAYER_GEOMETRY_CONFIG.forEach((geom, geomIndex) => {
    if (geomIndex >= playerCount) return;
    let displayColor = players[geomIndex]?.color || baseColors[geomIndex]?.code || 'grey';

    // --- MODIFICATION FOR HOME AREA CELLS ---
    // Old home area background:
    // ctx.fillStyle = displayColor.replace(')', ', 0.3)').replace('var(', 'rgba(');
    // ctx.fillRect(geom.homeArea.x * CELL_SIZE, geom.homeArea.y * CELL_SIZE, geom.homeArea.w * CELL_SIZE, geom.homeArea.h * CELL_SIZE);
    // ctx.strokeStyle = displayColor; ctx.lineWidth = 2;
    // ctx.strokeRect(geom.homeArea.x * CELL_SIZE, geom.homeArea.y * CELL_SIZE, geom.homeArea.w * CELL_SIZE, geom.homeArea.h * CELL_SIZE);

    // New: Fill individual cells in home area
    ctx.lineWidth = 1; // Thinner lines for inner cells
    for (let r = 0; r < geom.homeArea.h; r++) {
        for (let c = 0; c < geom.homeArea.w; c++) {
            ctx.fillStyle = displayColor; // Solid player color
            ctx.fillRect(
                (geom.homeArea.x + c) * CELL_SIZE,
                (geom.homeArea.y + r) * CELL_SIZE,
                CELL_SIZE,
                CELL_SIZE
            );
            ctx.strokeStyle = displayColor.startsWith('var(--yellow)') ? '#8c7000' : '#555'; // Darker border for cells, special for yellow
            ctx.strokeRect(
                (geom.homeArea.x + c) * CELL_SIZE,
                (geom.homeArea.y + r) * CELL_SIZE,
                CELL_SIZE,
                CELL_SIZE
            );
        }
    }
    // Draw a thicker outer border for the whole home area
    ctx.strokeStyle = displayColor;
    ctx.lineWidth = 3; // Thicker outer border
    ctx.strokeRect(geom.homeArea.x * CELL_SIZE, geom.homeArea.y * CELL_SIZE, geom.homeArea.w * CELL_SIZE, geom.homeArea.h * CELL_SIZE);
    // --- END MODIFICATION ---


    geom.homePathSquaresGrid.forEach((sq) => {
        // Make home path squares also solid, but perhaps slightly lighter or different texture if needed
        // For now, making them solid too.
        ctx.fillStyle = displayColor; // Solid player color for home path as well
        ctx.fillRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        ctx.strokeStyle = displayColor.startsWith('var(--yellow)') ? '#8c7000' : '#555';
        ctx.lineWidth = 1;
        ctx.strokeRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
    });
});
// ...
Use code with caution.
JavaScript
And adjust token placement in home area if needed. The cones are bottom-aligned at y.
Original home token placement for circles:
// x = (geom.homeArea.x + 1 + (tokenIdx % 2) * 2.5 + 0.5) * CELL_SIZE;
// y = (geom.homeArea.y + 1 + Math.floor(tokenIdx / 2) * 2.5 + 0.5) * CELL_SIZE;
Use code with caution.
JavaScript
New placement for cones (base centered at x, bottom of base at y):
The y coordinate for drawToken is the bottom of the cone's base.
// Inside drawBoard(), for token.state === 'home'
// ...
const homeW = geom.homeArea.w; const homeH = geom.homeArea.h;
// Arrange in 2x2 pattern, ensuring base of cone is placed appropriately
const colIndex = tokenIdx % 2;
const rowIndex = Math.floor(tokenIdx / 2);

// Center of the cell where the token goes
const cellCenterX = (geom.homeArea.x + (colIndex === 0 ? homeW * 0.3 : homeW * 0.7)) * CELL_SIZE;
const cellCenterY = (geom.homeArea.y + (rowIndex === 0 ? homeH * 0.3 : homeH * 0.7)) * CELL_SIZE;

x = cellCenterX;
// y for drawToken is the *bottom* of the cone.
// If TOKEN_RADIUS is used for cone width, coneHeight is ~2*TOKEN_RADIUS.
// We want to place it so it looks centered in its quadrant.
// The previous y was center of circle. Now it's bottom of cone base.
// Let's try to place the *base center* of the cone at cellCenterY.
// The `drawToken` function draws upwards from y.
// So `y` should be `cellCenterY + (coneHeight / 2) - baseHeight` if we wanted the true center of the cone at cellCenterY.
// Or, more simply, place the bottom of the cone slightly below the visual center of its quadrant.
y = cellCenterY + TOKEN_RADIUS * 0.5; // Adjust this to make cones sit nicely. TOKEN_RADIUS here is a general size guide.
//...
Use code with caution.
JavaScript
This looks more complex than intended. Let's simplify cone placement in home.
The original homeCellX/Y were good for center positions.
If x,y in drawToken is the center of the base of the cone, and the cone draws upwards:
The y passed to drawToken should be the y-coordinate for the bottom of the cone base.
Let tokenCellXUnit, tokenCellYUnit be the center of the sub-quadrant for the token.
// Inside drawBoard(), for token.state === 'home'
const homeCellWidth = geom.homeArea.w / 2; // Assumes 2x2 arrangement
const homeCellHeight = geom.homeArea.h / 2;

const tokenCellXCenter = (geom.homeArea.x + (tokenIdx % 2) * homeCellWidth + homeCellWidth / 2) * CELL_SIZE;
const tokenCellYCenter = (geom.homeArea.y + Math.floor(tokenIdx / 2) * homeCellHeight + homeCellHeight / 2) * CELL_SIZE;

x = tokenCellXCenter;
// y for drawToken is the bottom edge of the cone's base.
// The cone height is TOKEN_RADIUS * 2.2. Base height is 20% of that.
// We want the cone to appear visually centered in its cell.
// Let's place the bottom of the cone such that its visual center aligns with tokenCellYCenter.
// Visual center of cone is roughly (y - coneHeight/2).
// So, tokenCellYCenter = y - coneHeight/2  =>  y = tokenCellYCenter + coneHeight/2
const coneTotalHeight = TOKEN_RADIUS * 2.2;
y = tokenCellYCenter + coneTotalHeight * 0.35; // Experiment with this offset. Aim to have cone sit nicely in cell.
Use code with caution.
JavaScript
The parameter TOKEN_RADIUS should also be adjusted. It was CELL_SIZE * 0.30. Cones might need to be slightly smaller or CELL_SIZE itself might need to be relative to a slightly smaller overall board drawing area if the cones take up more perceived space. For now, let's keep it and see.
Let's also make the star squares for safe spots more prominent. Maybe fill the whole square gold.
// Inside drawBoard(), for SAFE_SQUARE_INDICES:
// Old:
// ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--safe-star-color').trim();
// ctx.font = `${CELL_SIZE * 0.6}px Arial`;
// ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
// ctx.fillText('★', (sq[0] + 0.5) * CELL_SIZE, (sq[1] + 0.5) * CELL_SIZE);
// New:
if (ACTIVE_SAFE_SQUARE_INDICES.includes(index)) {
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--safe-star-color').trim();
    ctx.fillRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE); // Fill the square
    ctx.fillStyle = '#000'; // Star color
    ctx.font = `${CELL_SIZE * 0.7}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('★', (sq[0] + 0.5) * CELL_SIZE, (sq[1] + 0.55) * CELL_SIZE); // Slightly adjust star position if needed
    // Redraw border for safe square on top of fill
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim();
    ctx.lineWidth = 1;
    ctx.strokeRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
}
Use code with caution.
JavaScript
The TOKEN_RADIUS is currently CELL_SIZE * 0.30.
If CELL_SIZE is 600/15 = 40px. Then TOKEN_RADIUS = 12px.
Cone height = 12 * 2.2 = 26.4px. Base width = 12 * 1.8 = 21.6px. This should fit within a 40x40 cell.
Final check on click detection: dx * dx + dy * dy < TOKEN_RADIUS * TOKEN_RADIUS * 1.8 * 1.8.
The TOKEN_RADIUS here refers to the original circular token.
Since the cone base width is TOKEN_RADIUS * 1.8, the click area should probably be based on (TOKEN_RADIUS * 1.8 / 2) squared, or more simply, keep a generous circular click area around the cone's base center (x, y - baseHeight / 2). Or, since y in drawToken is the bottom of the base, and x is the center of the base width, click detection around (x, y - coneHeight / 2) (visual center) might be more intuitive.
Let clickDetectionRadius = coneHeight / 2.
The token.displayPos = {x, y} stores x as center of base, y as bottom of base.
So clickTargetX = token.displayPos.x, clickTargetY = token.displayPos.y - coneHeight / 2.
The click detection needs to be consistent.
Original: token.displayPos = {x,y} where x,y was center of circle.
New: token.displayPos = {x,y} where x is center of cone base, y is bottom of cone base.
Let's make handleCanvasClick use the y as the bottom of the cone, and check a rectangular area.
Or, for simplicity, use a circular area around the visual center of the cone.
Visual center approx: (token.displayPos.x, token.displayPos.y - coneHeight/2).
Click area radius: coneHeight/2 or coneBaseWidth/2. Let's use coneBaseWidth/2.
// handleCanvasClick:
// ...
const coneBaseWidthForClick = TOKEN_RADIUS * 1.8; // Consistent with drawToken
const coneHeightForClick = TOKEN_RADIUS * 2.2;
const visualCenterY = token.displayPos.y - coneHeightForClick / 2; // y is bottom of base

const dx = clickX - token.displayPos.x; // x is center of base
const dy = clickY - visualCenterY;
// Use a click radius ~ half the base width, or a bit more generous
if (dx * dx + dy * dy < (coneBaseWidthForClick * 0.6) * (coneBaseWidthForClick * 0.6) ) {
    // ...
}
Use code with caution.
JavaScript
This seems reasonable.
The prompt also mentioned styling for the path player color (e.g., Red's path of 5 squares before the main track). The current logic for player.geometry.startSquareGrid and drawing the main track already has some highlighting for start squares. The home path squares (geom.homePathSquaresGrid) are now solid. The initial squares of each arm on the main track could also be subtly tinted.
Let's try making the first 5-6 squares of each player's arm on the main track (before common areas) lightly tinted.
This is complex because MAIN_TRACK_COORDS is global. I'd need to identify which segments belong to whom.
Example: Red uses global track 0-5 as their "arm". Green uses 13-18.
I can add this logic inside the MAIN_TRACK_COORDS.forEach loop.
// Inside drawBoard(), in MAIN_TRACK_COORDS.forEach((sq, index) => { ... })
// ...
// Add tint for player arm segments on main track
ACTIVE_PLAYER_GEOMETRY_CONFIG.forEach((geom, playerGeomIndex) => {
    if (playerGeomIndex >= playerCount) return;
    const player = players[playerGeomIndex]; // Find the player associated with this geometry
    if (!player) return;

    // Determine the range of global track indices for this player's initial arm segment
    // This is typically 6 squares from their startPosGlobal if it's a simple arm
    // Or 5 squares for the path before the first turn.
    const armLength = 5; // Number of squares in the initial colored part of the arm
    if (index >= geom.startPosGlobal && index < geom.startPosGlobal + armLength) {
        // Check if this square is NOT a safe square already colored gold
        // And also not the player's specific start square (already colored)
        if (!ACTIVE_SAFE_SQUARE_INDICES.includes(index) && index !== geom.startPosGlobal) {
            ctx.fillStyle = player.color.replace(')', ', 0.15)').replace('var(', 'rgba('); // Very light tint
            ctx.fillRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
    }
});
// ... after this, the safe square drawing and start square drawing will overlay if needed.
Use code with caution.
JavaScript
This tinting should happen before drawing safe squares and start squares, so those take precedence.
One final detail: the home path squares for player "Yellow" are defined with var(--yellow). This color is very light, and borders might be hard to see. I added a specific dark yellow border for it. This needs to be applied consistently.
// Helper for borders against light colors like yellow
function getBorderColor(backgroundColor) {
    if (backgroundColor.includes('var(--yellow)')) {
        return '#a18800'; // Darker yellow/brown for yellow background
    }
    if (backgroundColor.includes('var(--green)')) {
        return '#1e8a4d'; // Darker green
    }
    // Add more cases if other light colors are problematic
    return '#333'; // Default dark border
}

// Usage example in drawBoard for home area cells:
// ctx.strokeStyle = getBorderColor(displayColor);
// And for home path squares:
// ctx.strokeStyle = getBorderColor(displayColor);
Use code with caution.
JavaScript
This looks like a solid plan.
Collapse to hide model thoughts

chevron_right
Okay, I've implemented the requested visual enhancements! This involves:
Solid Colored Home Yards: Each cell within a player's home base (yard) is now filled with the player's solid color, with thin internal borders. The overall yard also has a thicker border.
Cone-Shaped Tokens: Tokens are now drawn as 2D representations of road cones (a triangle on top of a small rectangular base). Their size is relative to the cell size.
Styled Home Paths: The 5 squares leading to the center (home stretch) are also filled with the player's solid color.
Tinted Arm Paths: The first 5 squares of each player's arm on the main track (leading from their start square) are now lightly tinted with their color (unless it's a safe square or their absolute start square, which get stronger coloring).
Enhanced Safe Squares: Safe "star" squares are now filled with gold color, with the star symbol on top, making them more prominent.
Better Borders for Light Colors: Added a helper function to use darker, more contrasted borders for light background colors like yellow.
How to Apply the Changes:
You'll need to replace the drawBoard and drawToken functions in your existing JavaScript with the new versions provided below. Also, add the getBorderColor helper function.
1. New getBorderColor Helper Function (add this to your script):
function getBorderColor(backgroundColorString) {
            // Analyzes the CSS variable string to pick a good border
            if (backgroundColorString.includes('var(--yellow)')) return '#a18800'; // Darker yellow/brown
            if (backgroundColorString.includes('var(--green)')) return '#1a7431';  // Darker green
            if (backgroundColorString.includes('var(--blue)')) return '#1b608c';   // Darker blue
            if (backgroundColorString.includes('var(--red)')) return '#a02c2c';     // Darker red
            if (backgroundColorString.includes('var(--purple)')) return '#6a3682'; // Darker purple
            if (backgroundColorString.includes('var(--orange)')) return '#a85915'; // Darker orange
            return '#333'; // Default dark border
        }
Use code with caution.
JavaScript
2. Updated drawToken Function (replace the old one):
function drawToken(x, y, color, tokenData, playerIndexOfTokenOwner) {
            // x, y is the center of the token's base for the cone
            // The cone draws upwards from y (y is the bottom line of the base)

            const visualSize = TOKEN_RADIUS * 1.1; // Base size reference for cone parts
            const coneHeight = visualSize * 2.2;   // Total height of the cone
            const baseHeight = coneHeight * 0.20;  // Height of the cylindrical base part
            const baseWidth  = visualSize * 1.8;   // Width of the cylindrical base

            const bodyHeight = coneHeight - baseHeight; // Height of the conical part
            const topPointY = y - coneHeight;         // Y-coordinate of the cone's tip
                                                      // (y is bottom of base, so total height up)
            const bodyBaseY = y - baseHeight;         // Y-coordinate where conical part meets cylindrical base

            ctx.save();

            // 1. Draw the cylindrical base
            ctx.fillStyle = color;
            ctx.fillRect(x - baseWidth / 2, y - baseHeight, baseWidth, baseHeight);

            // 2. Draw the conical body
            ctx.beginPath();
            ctx.moveTo(x, topPointY); // Tip of the cone
            ctx.lineTo(x - baseWidth / 2, bodyBaseY); // Bottom-left of conical part
            ctx.lineTo(x + baseWidth / 2, bodyBaseY); // Bottom-right of conical part
            ctx.closePath();
            ctx.fill();

            // 3. Draw outline
            const outlineColor = getBorderColor(color); // Use helper for good contrast
            ctx.strokeStyle = outlineColor;
            ctx.lineWidth = 1.5;

            // Outline base rectangle
            ctx.strokeRect(x - baseWidth / 2, y - baseHeight, baseWidth, baseHeight);
            
            // Outline conical body
            ctx.beginPath();
            ctx.moveTo(x, topPointY);
            ctx.lineTo(x - baseWidth / 2, bodyBaseY);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x, topPointY);
            ctx.lineTo(x + baseWidth / 2, bodyBaseY);
            ctx.stroke();

            // Highlight if movable
            if (players.length > 0 && turnOrder.length > 0) { // Ensure game state is ready
                const currentPlayerRealIndex = turnOrder[currentPlayerTurnIndex];
                if (humanPlayerCanMove && playerIndexOfTokenOwner === currentPlayerRealIndex) {
                    const isMovable = possibleMovesForHuman.some(move => move.tokenIndex === tokenData.id);
                    if (isMovable) {
                        ctx.strokeStyle = 'gold'; // Highlight color
                        ctx.lineWidth = 3;
                        // Re-stroke the outline with highlight color
                        ctx.strokeRect(x - baseWidth / 2, y - baseHeight, baseWidth, baseHeight);
                        ctx.beginPath();
                        ctx.moveTo(x, topPointY); ctx.lineTo(x - baseWidth / 2, bodyBaseY); ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x, topPointY); ctx.lineTo(x + baseWidth / 2, bodyBaseY); ctx.stroke();
                    }
                }
            }
            ctx.restore();
        }
Use code with caution.
JavaScript
3. Updated drawBoard Function (replace the old one):
function drawBoard() {
            ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--board-bg').trim();
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            // Draw Player Home Yards & Home Paths
            ACTIVE_PLAYER_GEOMETRY_CONFIG.forEach((geom, geomIndex) => {
                if (geomIndex >= playerCount) return; 
                let displayColor = players[geomIndex]?.color || baseColors[geomIndex]?.code || 'grey';
                let borderColor = getBorderColor(displayColor);

                // Fill individual cells in home area (yard)
                ctx.lineWidth = 1; 
                for (let r = 0; r < geom.homeArea.h; r++) {
                    for (let c = 0; c < geom.homeArea.w; c++) {
                        ctx.fillStyle = displayColor; // Solid player color
                        ctx.fillRect(
                            (geom.homeArea.x + c) * CELL_SIZE, (geom.homeArea.y + r) * CELL_SIZE,
                            CELL_SIZE, CELL_SIZE
                        );
                        ctx.strokeStyle = borderColor;
                        ctx.strokeRect(
                            (geom.homeArea.x + c) * CELL_SIZE, (geom.homeArea.y + r) * CELL_SIZE,
                            CELL_SIZE, CELL_SIZE
                        );
                    }
                }
                // Draw a thicker outer border for the whole home area
                ctx.strokeStyle = borderColor; // Use contrasted border for outer as well
                ctx.lineWidth = 2.5; 
                ctx.strokeRect(geom.homeArea.x * CELL_SIZE, geom.homeArea.y * CELL_SIZE, geom.homeArea.w * CELL_SIZE, geom.homeArea.h * CELL_SIZE);
                
                // Home Path Squares (leading to center)
                geom.homePathSquaresGrid.forEach((sq) => {
                    ctx.fillStyle = displayColor; 
                    ctx.fillRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    ctx.strokeStyle = borderColor;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                });
            });

            // Draw Main Track Squares
            ACTIVE_MAIN_TRACK_COORDS.forEach((sq, index) => {
                // Light tint for player arm segments on main track (drawn first)
                ACTIVE_PLAYER_GEOMETRY_CONFIG.forEach((geom, playerGeomIndex) => {
                    if (playerGeomIndex >= playerCount || !players[playerGeomIndex]) return;
                    const playerAssociatedWithGeom = players[playerGeomIndex];
                    const armLength = 5; 
                    if (index >= geom.startPosGlobal && index < geom.startPosGlobal + armLength) {
                        if (!ACTIVE_SAFE_SQUARE_INDICES.includes(index) && index !== geom.startPosGlobal) {
                            ctx.fillStyle = playerAssociatedWithGeom.color.replace(')', ', 0.18)').replace('var(', 'rgba('); // Light tint
                            ctx.fillRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        }
                    }
                });

                // Default square border
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim();
                ctx.lineWidth = 1;
                ctx.strokeRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                
                // Player Start Squares (stronger color)
                ACTIVE_PLAYER_GEOMETRY_CONFIG.forEach((geom, geomIndex) => {
                    if (geomIndex >= playerCount || !players[geomIndex]) return;
                    if (geom.startPosGlobal === index) {
                        ctx.fillStyle = players[geomIndex].color.replace(')', ', 0.45)').replace('var(', 'rgba('); // Stronger tint for start
                        ctx.fillRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        // Redraw border on top of fill
                        ctx.strokeStyle = getBorderColor(players[geomIndex].color);
                        ctx.strokeRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                });

                // Safe Squares (Star) - drawn last to be on top of tints
                if (ACTIVE_SAFE_SQUARE_INDICES.includes(index)) {
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--safe-star-color').trim();
                    ctx.fillRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE); // Fill the square gold
                    
                    ctx.fillStyle = '#000'; // Star color
                    ctx.font = `${CELL_SIZE * 0.65}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText('★', (sq[0] + 0.5) * CELL_SIZE, (sq[1] + 0.55) * CELL_SIZE); 
                    // Redraw border for safe square
                    ctx.strokeStyle = '#8c7000'; // Dark gold border for safe squares
                    ctx.lineWidth = 1.5;
                    ctx.strokeRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            });
            
            // Draw Center Finish Area (Triangle/Diamond)
            const mid = Math.floor(GRID_SIZE / 2);
            ctx.beginPath();
            ctx.moveTo((mid -1) * CELL_SIZE, mid * CELL_SIZE); 
            ctx.lineTo(mid * CELL_SIZE, (mid-1) * CELL_SIZE);
            ctx.lineTo((mid +1) * CELL_SIZE, mid * CELL_SIZE); 
            ctx.lineTo(mid * CELL_SIZE, (mid+1) * CELL_SIZE);
            ctx.closePath(); 
            ctx.fillStyle = '#e0e0e0'; // Light gray for center area
            ctx.fill();
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim();
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Draw Tokens
            players.forEach((player, playerIdx) => {
                if (!player || !player.tokens || !player.geometry) return;
                const geom = player.geometry;
                player.tokens.forEach((token, tokenIdx) => {
                    let x, yDraw; // x is center of cone base, yDraw is bottom line of cone base
                    
                    if (token.state === 'home') {
                        const homeCellWidth = geom.homeArea.w / 2; 
                        const homeCellHeight = geom.homeArea.h / 2;
                        const tokenCellXCenter = (geom.homeArea.x + (tokenIdx % 2) * homeCellWidth + homeCellWidth / 2) * CELL_SIZE;
                        const tokenCellYCenter = (geom.homeArea.y + Math.floor(tokenIdx / 2) * homeCellHeight + homeCellHeight / 2) * CELL_SIZE;
                        
                        x = tokenCellXCenter;
                        const coneTotalVisualHeight = (TOKEN_RADIUS * 1.1) * 2.2;
                        // Place the bottom of the cone so it looks centered vertically
                        yDraw = tokenCellYCenter + coneTotalVisualHeight * 0.3; // Adjust this multiplier for best visual fit
                    } else if (token.state === 'track') {
                        const globalPos = token.globalTrackPos;
                        if (globalPos !== -1 && globalPos < ACTIVE_MAIN_TRACK_COORDS.length) {
                            const sq = ACTIVE_MAIN_TRACK_COORDS[globalPos];
                            x = (sq[0] + 0.5) * CELL_SIZE; 
                            yDraw = (sq[1] + 0.85) * CELL_SIZE; // Position cone base near bottom of cell
                        } else { return; }
                    } else if (token.state === 'homestretch') {
                        if(token.position >= 0 && token.position < geom.homePathSquaresGrid.length) {
                            const sq = geom.homePathSquaresGrid[token.position];
                            x = (sq[0] + 0.5) * CELL_SIZE; 
                            yDraw = (sq[1] + 0.85) * CELL_SIZE;
                        } else { return; }
                    } else { // finished state
                        const finalHomeSqIdx = Math.min(HOME_STRETCH_LENGTH -1, geom.homePathSquaresGrid.length -1);
                        const finalHomeSq = geom.homePathSquaresGrid[finalHomeSqIdx];
                        // Cluster finished tokens near their final home spot
                        const offsetX = (tokenIdx - (TOKENS_PER_PLAYER -1)/2) * TOKEN_RADIUS * 0.5;
                        x = (finalHomeSq[0] + 0.5) * CELL_SIZE + offsetX; 
                        yDraw = (finalHomeSq[1] + 0.85) * CELL_SIZE;
                    }
                    token.displayPos = {x: x, y: yDraw}; // Store base x and bottom y
                    drawToken(x, yDraw, player.color, token, playerIdx);
                });
            });
        }
Use code with caution.
JavaScript
4. Adjusted handleCanvasClick (for cone click detection):
function handleCanvasClick(event) {
            if (!humanPlayerCanMove || !gameActive) return;
            const rect = canvasEl.getBoundingClientRect();
            const clickX = event.clientX - rect.left; 
            const clickY = event.clientY - rect.top;
            
            if (!players || players.length === 0 || turnOrder.length === 0) return;
            const playerIndex = turnOrder[currentPlayerTurnIndex];
            const player = players[playerIndex];
            if (!player || !player.tokens) return;

            for (const move of possibleMovesForHuman) {
                const token = player.tokens[move.tokenIndex];
                if (!token.displayPos || token.displayPos.x == undefined || token.displayPos.y == undefined) continue; 
                
                const visualSize = TOKEN_RADIUS * 1.1;
                const coneTotalHeight = visualSize * 2.2;
                const coneBaseWidth = visualSize * 1.8;

                // Visual center of the cone
                const coneVisualCenterX = token.displayPos.x;
                const coneVisualCenterY = token.displayPos.y - coneTotalHeight / 2; // displayPos.y is bottom of base

                const dx = clickX - coneVisualCenterX;
                const dy = clickY - coneVisualCenterY;

                // Click detection based on a generous rectangle around the cone's visual center
                // Half height and half width from visual center
                const clickRadiusX = coneBaseWidth * 0.7; // Generous horizontal click area
                const clickRadiusY = coneTotalHeight * 0.5; // Full vertical click area

                if (Math.abs(dx) < clickRadiusX && Math.abs(dy) < clickRadiusY) {
                    executeMove(playerIndex, move); 
                    humanPlayerCanMove = false; 
                    possibleMovesForHuman = []; 
                    drawBoard(); // Redraw to remove highlights
                    return;
                }
            }
        }
Use code with caution.
JavaScript
What these changes do:
The Ludo board will look much more vibrant with player-colored home areas and paths.
The tokens will be cone-shaped, giving a unique look.
Safe squares will be clearly identifiable with a gold fill.
The initial segments of each player's path on the main track will have a subtle hint of their color.
Remember to test these changes thoroughly, especially the token placement in different states (home, track, homestretch, finished) and the click detection for the new cone shapes. The values for cone dimensions and placement offsets in drawToken and drawBoard might need slight tweaking for optimal visual appeal.
