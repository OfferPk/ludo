<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Ludo Game - Enhanced</title>
    <style>
        :root {
            --red: #e74c3c;
            --green: #2ecc71;
            --blue: #3498db;
            --yellow: #f1c40f;
            --purple: #9b59b6;
            --orange: #e67e22;
            --teal: #1abc9c; 
            --pink: #e91e63; 
            --gray: #ecf0f1;
            --dark-gray: #333;
            --light-gray: #f5f5f5;
            --board-bg: #fdfdfd;
            --safe-star-color: #ffd700;
        }
        
        body {
            margin: 0;
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: var(--light-gray);
            min-height: 100vh;
            padding-bottom: 20px;
        }
        
        header {
            width: 100%;
            background: linear-gradient(135deg, #6e48aa 0%, #9d50bb 100%);
            color: white;
            padding: 15px 0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            position: sticky;
            top:0;
            z-index: 500; /* Ensure header is on top */
        }
        
        h1 { margin: 0; font-size: 2.2rem; }
        
        .back-button, .close-button {
            position: absolute; top: 50%; transform: translateY(-50%);
            background: none; border: none; color: white; font-size: 1.5rem;
            cursor: pointer; padding: 5px 10px; border-radius: 5px; transition: background 0.3s;
        }
        .back-button { left: 20px; }
        .close-button { right: 20px; }
        .back-button:hover, .close-button:hover { background: rgba(255,255,255,0.2); }
        
        .player-selection { /* Screen for profile, bets, player count */
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--light-gray); /* Changed from dark overlay for better readability */
            display: flex; flex-direction: column; justify-content: flex-start; /* Align to top */
            align-items: center;
            z-index: 100; overflow-y: auto; padding-top: 80px; /* Space for sticky header */
            box-sizing: border-box;
        }
        .player-selection-content {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
            max-width: 700px;
            width: 90%;
            margin: 20px auto; /* Centering and spacing */
            text-align: center;
        }

        .player-selection h2 { color: var(--dark-gray); font-size: 1.8rem; margin-bottom: 20px; }
        .player-options { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; margin-bottom:20px;}
        .player-option {
            background: var(--gray); padding: 15px; border-radius: 10px; text-align: center;
            cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            min-width: 120px; border: 2px solid transparent;
        }
        .player-option:hover, .player-option.selected {
            transform: translateY(-3px); box-shadow: 0 4px 10px rgba(0,0,0,0.15); border-color: #6e48aa;
        }
        .player-option h3 { font-size: 1.2rem; margin: 0 0 5px 0; color: #6e48aa; }
        .player-option p { color: #555; margin: 0; font-size:0.8em; }

        .profile-rewards-section, .betting-section {
            margin-top: 20px; padding: 15px; background: #f9f9f9; border-radius: 10px; border: 1px solid #eee;
        }
        .profile-rewards-section h3, .betting-section h3 { margin-top:0; color: var(--dark-gray); font-size: 1.3rem; margin-bottom:15px;}
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom:15px; }
        .stat-item { background: white; padding: 10px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); font-size: 0.9em;}
        .stat-item strong { color: #6e48aa; font-size: 1.1em;}
        #watchAdButton { background: linear-gradient(135deg, var(--green) 0%, #58d68d 100%); margin-top:10px; width:100%; padding: 10px; font-size: 0.9em;}
        #watchAdButton:disabled { background: #aaa; cursor: not-allowed;}
        #adRewardMessage {font-size:0.8em; margin-top:8px; color: #666;}

        .bet-options { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; }
        .bet-option {
            padding: 8px 12px; background: white; border: 1px solid #ddd; border-radius: 20px;
            cursor: pointer; transition: all 0.2s; font-weight: bold; font-size:0.85em;
        }
        .bet-option:hover { background: #efefef; }
        .bet-option.selected { background: #6e48aa; color: white; border-color: #6e48aa;}
        #startGameButton { 
            margin-top:25px; 
            background: linear-gradient(135deg, var(--orange) 0%, #f39c12 100%); 
            width:100%; font-size:1.2em; padding: 12px;
            border:none; color:white; border-radius: 8px; cursor:pointer; transition: opacity 0.3s;
        }
        #startGameButton:hover { opacity: 0.9; }


        .game-container {
            position: relative;
            margin: 20px;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            display: none; /* Initially hidden */
            flex-direction: column;
            align-items: center;
        }
        canvas {
            background: var(--board-bg);
            border: 3px solid var(--dark-gray);
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
        }
        .controls { margin-top: 20px; display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; align-items: center; }
        .dice {
            width: 80px; height: 80px; background: linear-gradient(135deg, #ff5e62 0%, #ff9966 100%);
            border-radius: 15px; color: white; font-size: 48px; display: flex; align-items: center;
            justify-content: center; cursor: pointer; box-shadow: 0 6px 10px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease; user-select: none;
        }
        .dice:hover { transform: scale(1.05); box-shadow: 0 8px 15px rgba(0, 0, 0, 0.3); }
        .dice.animate { animation: diceRoll 0.5s ease-in-out; background: linear-gradient(135deg, #ffcc33 0%, #ffb347 100%); }
        @keyframes diceRoll {
            0% { transform: rotate(0deg) scale(1); } 25% { transform: rotate(90deg) scale(1.2); }
            50% { transform: rotate(180deg) scale(1.1); } 75% { transform: rotate(270deg) scale(1.2); }
            100% { transform: rotate(360deg) scale(1); }
        }
        .countdown { width: 150px; height: 15px; background: #ddd; position: relative; border-radius: 10px; overflow: hidden; }
        .countdown-bar { height: 100%; background: linear-gradient(90deg, #ff5f6d, #ffc371); width: 100%; transition: width 0.5s linear; border-radius: 10px; }
        
        .settings-panel { margin-top: 20px; background: #fff; padding: 20px; border-radius: 15px; box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1); width: 100%; max-width: 600px; }
        .setting-row { display: flex; align-items: center; margin: 10px 0; padding: 8px; background: #f9f9f9; border-radius: 8px; }
        .setting-row label { margin-left: 10px; font-weight: 500; color: var(--dark-gray); font-size: 0.9em;}
        
        .token-balances { display: flex; gap: 10px; margin-top: 15px; justify-content: center; flex-wrap: wrap; max-width: 600px; }
        .token-balance {
            font-size: 14px; font-weight: bold; padding: 6px 12px; border-radius: 15px;
            color: white; min-width: 70px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .custom-turn-order { display: flex; gap: 10px; margin-top: 15px; justify-content: center; flex-wrap: wrap; align-items: center; max-width: 600px; }
        .custom-turn-order label { font-weight: bold; color: #555; }
        .custom-turn-order input { width: 50px; padding: 8px; border: 2px solid #ddd; border-radius: 8px; text-align: center; font-weight: bold; }
        .custom-turn-order input:focus { outline: none; border-color: #6e48aa; }
        
        button { /* General button style, specific buttons can override */
            background: linear-gradient(135deg, #6e48aa 0%, #9d50bb 100%); color: white; border: none;
            padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: bold;
            transition: all 0.3s ease; box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 10px rgba(0,0,0,0.2); }
        
        .game-info { margin-top: 15px; padding: 15px; background: white; border-radius: 10px; box-shadow: 0 3px 10px rgba(0,0,0,0.1); width: 100%; max-width: 600px; text-align: center;}
        .current-player { font-size: 1.2rem; font-weight: bold; margin-bottom: 10px; }
        .dice-value { font-size: 1.5rem; font-weight: bold; color: var(--red); }
        .game-message { margin-top: 10px; padding: 10px; border-radius: 5px; background: #f8f9fa; font-weight: 500; min-height: 20px; }
        
        .win-message, .exit-confirmation, .forced-close-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 600; color: white; text-align: center; padding: 20px; box-sizing: border-box;
        }
        .win-message h2 { font-size: 3rem; margin-bottom: 20px; color: gold; }
        .win-message button { margin-top: 30px; font-size: 1.2rem; padding: 15px 30px; }

        .forced-close-overlay h2 { font-size: 2.5rem; margin-bottom: 15px; }
        .forced-close-overlay p { font-size: 1.2rem; margin-bottom: 20px; }
        .forced-close-overlay .timer { font-size: 1.5rem; color: var(--yellow); }

        .exit-dialog { background: white; padding: 30px; border-radius: 15px; text-align: center; max-width: 400px; width: 90%; color: var(--dark-gray); }
        .exit-dialog h3 { margin-top: 0; }
        .exit-buttons { display: flex; justify-content: center; gap: 15px; margin-top: 20px; }
        .exit-buttons button { min-width: 100px; }
        .exit-buttons button#confirmExitButton { background: linear-gradient(135deg, #ff5e62 0%, #ff9966 100%); }
        .exit-buttons button:last-child { background: linear-gradient(135deg, #4CAF50 0%, #2ecc71 100%); }

    </style>
</head>
<body>
    <header>
        <button class="back-button" id="backButton" style="display: none;">← Back</button>
        <h1>Smart Ludo Game</h1>
        <button class="close-button" id="closeButton" style="display: none;">×</button>
    </header>

    <div class="player-selection" id="playerSelectionScreen">
        <div class="player-selection-content">
            <h2>Welcome to Smart Ludo!</h2>

            <div class="profile-rewards-section">
                <h3>Your Profile & Rewards</h3>
                <div class="stats-grid">
                    <div class="stat-item">Coins: <strong id="playerCoins">0</strong></div>
                    <div class="stat-item">Wins: <strong id="playerWins">0</strong></div>
                    <div class="stat-item">Losses: <strong id="playerLosses">0</strong></div>
                </div>
                <button id="watchAdButton" onclick="watchAdForCoins()">Watch Ad for Coins (+500)</button>
                <p id="adRewardMessage" style="font-size:0.8em; margin-top:5px;"></p>
            </div>

            <div class="betting-section">
                <h3>Select Bet Amount</h3>
                <div class="bet-options" id="betOptionsContainer"></div>
            </div>
            
            <h3>Select Number of Players</h3>
            <div class="player-options" id="playerOptionsContainer">
                <div class="player-option" data-value="2"><h3>2 Players</h3><p>1v1 Classic</p></div>
                <div class="player-option" data-value="3"><h3>3 Players</h3><p>Triple Threat</p></div>
                <div class="player-option" data-value="4"><h3>4 Players</h3><p>Full Board</p></div>
                <div class="player-option" data-value="6"><h3>6 Players</h3><p>Star Board Action</p></div>
            </div>
            <button id="startGameButton" onclick="validateAndStartGame()">Start Game</button>
        </div>
    </div>

    <div class="game-container" id="gameContainer">
         <canvas id="ludoCanvas" width="600" height="600"></canvas>
        <div class="game-info">
            <div class="current-player" id="currentPlayer">Current Player: Red</div>
            <div class="dice-value" id="diceValue">Dice: -</div>
            <div class="game-message" id="gameMessage">Welcome! Click dice or token.</div>
        </div>
        <div class="controls">
            <div class="dice" id="dice">🎲</div>
            <div class="countdown" id="countdown"><div class="countdown-bar" id="countdownBar"></div></div>
        </div>
        <div class="token-balances" id="tokenBalances"></div>
        <div class="custom-turn-order" id="customTurnOrderContainer">
            <label>Turn Order:</label>
            <button onclick="updateTurnOrder()">Update Order</button>
        </div>
        <div class="settings-panel">
            <div class="setting-row"><input type="checkbox" id="autoMode" checked><label for="autoMode">Auto Mode</label></div>
            <div class="setting-row"><input type="checkbox" id="autoRoll" checked><label for="autoRoll">Auto-Roll</label></div>
            <div class="setting-row"><input type="checkbox" id="smartCapture" checked><label for="smartCapture">Smart Capture (AI)</label></div>
            <div class="setting-row"><input type="checkbox" id="safeMove" checked><label for="safeMove">Safe Moves (AI)</label></div>
            <div class="setting-row"><input type="checkbox" id="aiVsAi"><label for="aiVsAi">AI vs AI Simulation</label></div>
            <div class="setting-row"><input type="checkbox" id="soundEffects" checked><label for="soundEffects">Sound Effects</label></div>
            <button onclick="resetGameConfirm()" style="margin-top: 15px; width: 100%;">Reset Game</button>
        </div>
    </div>

    <div class="win-message" id="winMessage">
        <h2 id="winnerText">Player Wins!</h2>
        <p id="winDetails">Congratulations on your victory!</p>
        <button onclick="returnToHome()">Back to Home</button>
    </div>

    <div class="exit-confirmation" id="exitConfirmation">
        <div class="exit-dialog">
            <h3 id="exitDialogTitle">Exit Game</h3>
            <p id="exitDialogMessage">Are you sure?</p>
            <div class="exit-buttons">
                <button id="confirmExitButton" onclick="confirmQuitGame()">Yes</button> <!-- Default to Quit -->
                <button onclick="cancelExit()">No</button>
            </div>
        </div>
    </div>

    <div class="forced-close-overlay" id="forcedCloseOverlay">
        <h2 id="forcedCloseTitle">Game Over</h2>
        <p id="forcedCloseMessage">Player X left the game. Player Y wins!</p>
        <p>Returning to home in <span id="forcedCloseTimer" class="timer">5</span>s</p>
    </div>

    <audio id="diceSound" src="https://assets.mixkit.co/sfx/preview/mixkit-plastic-dice-roll-1494.mp3" preload="auto"></audio>
    <audio id="moveSound" src="https://assets.mixkit.co/sfx/preview/mixkit-unlock-game-notification-253.mp3" preload="auto"></audio>
    <audio id="captureSound" src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-explosion-2759.mp3" preload="auto"></audio>
    <audio id="winSound" src="https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3" preload="auto"></audio>
    <audio id="errorSound" src="https://assets.mixkit.co/sfx/preview/mixkit-game-show-wrong-answer-buzz-950.mp3" preload="auto"></audio>
    <audio id="coinSound" src="https://assets.mixkit.co/sfx/preview/mixkit-game-success-alert-2039.mp3" preload="auto"></audio>
    <audio id="backgroundMusic" loop src="https://assets.mixkit.co/music/preview/mixkit-game-show-suspense-waiting-668.mp3" preload="auto"></audio>

    <script>
        // Constants for localStorage
        const LS_COINS_KEY = 'ludoSmartCoinsV3'; // Incremented version
        const LS_WINS_KEY = 'ludoSmartWinsV3';
        const LS_LOSSES_KEY = 'ludoSmartLossesV3';
        const LS_JOINING_BONUS_KEY = 'ludoSmartJoiningBonusReceivedV3';
        const LS_LAST_AD_DATE_KEY = 'ludoSmartLastAdDateV3';
        const LS_TODAY_AD_COINS_KEY = 'ludoSmartTodayAdCoinsV3';
        const DAILY_AD_COIN_LIMIT = 5000;
        const AD_REWARD_AMOUNT = 500;
        const JOINING_BONUS_AMOUNT = 5000;

        const BET_AMOUNTS = [500, 1000, 10000, 50000, 100000, 500000, 1000000, 5000000, 10000000];
        let selectedBetAmount = BET_AMOUNTS[0];
        let selectedPlayerCount = 0; // Set by UI click

        let playerCoins = 0;
        let playerWins = 0;
        let playerLosses = 0;

        const canvasEl = document.getElementById('ludoCanvas'); // Renamed to avoid conflict
        const ctx = canvasEl.getContext('2d');
        
        let GRID_SIZE = 15; 
        let CELL_SIZE = canvasEl.width / GRID_SIZE;
        let TOKEN_RADIUS = CELL_SIZE * 0.35;
        const TOKENS_PER_PLAYER = 4;
        let MAIN_TRACK_LENGTH = 52; 
        const HOME_STRETCH_LENGTH = 6;

        let players = [];
        let playerCount = 0; // Global, set by selectedPlayerCount via startGameSetup
        let currentPlayerTurnIndex = 0; 
        let currentDiceValue = 0;
        let gameActive = false;
        let turnOrder = []; 
        let humanPlayerCanMove = false;
        let possibleMovesForHuman = [];
        let countdownInterval;
        let extraTurnReason = null;

        const baseColors = [ 
            { name: 'Red',    code: 'var(--red)'},
            { name: 'Green',  code: 'var(--green)'},
            { name: 'Yellow', code: 'var(--yellow)'}, // Note: Ludo often has Green, then Yellow, then Blue. This order is R,G,Y,B,...
            { name: 'Blue',   code: 'var(--blue)'},
            { name: 'Purple', code: 'var(--purple)'},
            { name: 'Orange', code: 'var(--orange)'}
        ];
        
        let ACTIVE_PLAYER_GEOMETRY_CONFIG = [];
        let ACTIVE_MAIN_TRACK_COORDS = [];
        let ACTIVE_SAFE_SQUARE_INDICES = [];
        const DEFAULT_MAIN_TRACK_COORDS_4P = [ /* Standard 52 squares for 4-player board */
            [1,6],[2,6],[3,6],[4,6],[5,6], [6,5],[6,4],[6,3],[6,2],[6,1],[6,0], [7,0],[8,0],
            [8,1],[8,2],[8,3],[8,4],[8,5], [9,6],[10,6],[11,6],[12,6],[13,6],[14,6], [14,7],[14,8],
            [13,8],[12,8],[11,8],[10,8],[9,8], [8,9],[8,10],[8,11],[8,12],[8,13],[8,14], [7,14],[6,14],
            [6,13],[6,12],[6,11],[6,10],[6,9], [5,8],[4,8],[3,8],[2,8],[1,8],[0,8], [0,7],[0,6]
        ];
        const DEFAULT_SAFE_SQUARE_INDICES_4P = [0, 8, 13, 21, 26, 34, 39, 47];
        const DEFAULT_PLAYER_GEOMETRY_4P = [ // Red, Green, Yellow (as P2), Blue (as P3)
            { name:'Red', homeArea: { x: 0, y: 0, w: 6, h: 6 }, startSquareGrid: [1, 6], startPosGlobal: 0, homePathEntryGlobalTrackPos: 50, homePathSquaresGrid: [[6,1],[6,2],[6,3],[6,4],[6,5],[6,6]] },
            { name:'Green', homeArea: { x: 9, y: 0, w: 6, h: 6 }, startSquareGrid: [8, 1], startPosGlobal: 13, homePathEntryGlobalTrackPos: 11, homePathSquaresGrid: [[13,6],[12,6],[11,6],[10,6],[9,6],[8,6]] },
            { name:'Yellow', homeArea: { x: 9, y: 9, w: 6, h: 6 }, startSquareGrid: [6, 13], startPosGlobal: 26, homePathEntryGlobalTrackPos: 24, homePathSquaresGrid: [[8,13],[8,12],[8,11],[8,10],[8,9],[8,8]] },
            { name:'Blue', homeArea: { x: 0, y: 9, w: 6, h: 6 }, startSquareGrid: [13, 8], startPosGlobal: 39, homePathEntryGlobalTrackPos: 37, homePathSquaresGrid: [[1,8],[2,8],[3,8],[4,8],[5,8],[6,8]] }
        ];


        // --- Player Profile & Coin Management ---
        function initPlayerProfile() {
            const storedCoins = localStorage.getItem(LS_COINS_KEY);
            const joiningBonusReceived = localStorage.getItem(LS_JOINING_BONUS_KEY) === 'true';

            if (storedCoins === null) {
                playerCoins = JOINING_BONUS_AMOUNT;
                localStorage.setItem(LS_COINS_KEY, playerCoins.toString());
                localStorage.setItem(LS_JOINING_BONUS_KEY, 'true');
                 setTimeout(() => alert(`Welcome! You've received ${JOINING_BONUS_AMOUNT} joining bonus coins!`), 100);
            } else {
                playerCoins = parseInt(storedCoins);
                if (!joiningBonusReceived && playerCoins < JOINING_BONUS_AMOUNT) { // Give bonus if missed and not already rich
                    playerCoins += JOINING_BONUS_AMOUNT;
                    localStorage.setItem(LS_COINS_KEY, playerCoins.toString());
                    localStorage.setItem(LS_JOINING_BONUS_KEY, 'true');
                    setTimeout(() => alert(`Welcome back! We've topped up your account with ${JOINING_BONUS_AMOUNT} bonus coins!`), 100);
                }
            }

            playerWins = parseInt(localStorage.getItem(LS_WINS_KEY) || '0');
            playerLosses = parseInt(localStorage.getItem(LS_LOSSES_KEY) || '0');
            updateProfileDisplay();
            setupBetOptions();
            setupPlayerCountOptions();
        }

        function updateProfileDisplay() {
            document.getElementById('playerCoins').textContent = playerCoins.toLocaleString();
            document.getElementById('playerWins').textContent = playerWins;
            document.getElementById('playerLosses').textContent = playerLosses;
            checkAdRewardStatus();
        }

        function addCoins(amount) {
            playerCoins += amount;
            localStorage.setItem(LS_COINS_KEY, playerCoins.toString());
            updateProfileDisplay();
            playSound('coinSound');
        }

        function deductCoins(amount) {
            playerCoins -= amount;
            localStorage.setItem(LS_COINS_KEY, playerCoins.toString());
            updateProfileDisplay();
        }

        function incrementWins() { playerWins++; localStorage.setItem(LS_WINS_KEY, playerWins.toString()); updateProfileDisplay(); }
        function incrementLosses() { playerLosses++; localStorage.setItem(LS_LOSSES_KEY, playerLosses.toString()); updateProfileDisplay(); }

        function checkAdRewardStatus() {
            const today = new Date().toISOString().split('T')[0];
            const lastAdDate = localStorage.getItem(LS_LAST_AD_DATE_KEY);
            let todayAdCoins = 0;

            if (lastAdDate === today) {
                todayAdCoins = parseInt(localStorage.getItem(LS_TODAY_AD_COINS_KEY) || '0');
            } else { // New day or first time
                localStorage.setItem(LS_LAST_AD_DATE_KEY, today);
                localStorage.setItem(LS_TODAY_AD_COINS_KEY, '0');
            }
            
            const adButton = document.getElementById('watchAdButton');
            const adMessage = document.getElementById('adRewardMessage');
            if (todayAdCoins >= DAILY_AD_COIN_LIMIT) {
                adButton.disabled = true;
                adMessage.textContent = `Daily ad reward limit reached. Try tomorrow.`;
            } else {
                adButton.disabled = false;
                adMessage.textContent = `Earn ${AD_REWARD_AMOUNT} coins. ${DAILY_AD_COIN_LIMIT - todayAdCoins} coins left today.`;
            }
        }

        function watchAdForCoins() {
            const adButton = document.getElementById('watchAdButton');
            adButton.disabled = true;
            adButton.textContent = "Loading Ad...";
            setTimeout(() => {
                addCoins(AD_REWARD_AMOUNT);
                let todayAdCoins = parseInt(localStorage.getItem(LS_TODAY_AD_COINS_KEY) || '0');
                todayAdCoins += AD_REWARD_AMOUNT;
                localStorage.setItem(LS_TODAY_AD_COINS_KEY, todayAdCoins.toString());
                alert(`You earned ${AD_REWARD_AMOUNT} coins!`);
                adButton.textContent = `Watch Ad for Coins (+${AD_REWARD_AMOUNT})`;
                checkAdRewardStatus();
            }, 1500);
        }

        function setupBetOptions() {
            const container = document.getElementById('betOptionsContainer');
            container.innerHTML = ''; // Clear old options
            BET_AMOUNTS.forEach(amount => {
                const button = document.createElement('div');
                button.className = 'bet-option';
                button.textContent = amount >= 1000000 ? `${amount/1000000}M` : (amount >= 1000 ? `${amount/1000}K` : amount.toString());
                button.dataset.value = amount;
                if (amount === selectedBetAmount) button.classList.add('selected');
                button.onclick = () => {
                    selectedBetAmount = amount;
                    document.querySelectorAll('.bet-option').forEach(btn => btn.classList.remove('selected'));
                    button.classList.add('selected');
                };
                container.appendChild(button);
            });
        }
        
        function setupPlayerCountOptions() {
            const container = document.getElementById('playerOptionsContainer');
            container.querySelectorAll('.player-option').forEach(option => {
                option.onclick = () => {
                    selectedPlayerCount = parseInt(option.dataset.value);
                     container.querySelectorAll('.player-option').forEach(btn => btn.classList.remove('selected'));
                    option.classList.add('selected');
                }
            });
        }

        function validateAndStartGame() {
            if (selectedPlayerCount === 0) { alert("Please select the number of players."); return; }
            if (playerCoins < selectedBetAmount) { alert(`Not enough coins. Bet: ${selectedBetAmount.toLocaleString()}, Your balance: ${playerCoins.toLocaleString()}`); return; }
            
            deductCoins(selectedBetAmount);
            playerCount = selectedPlayerCount; // Set the global playerCount for Ludo logic
            startGameSetupInternal(playerCount); // Call Ludo game's internal setup
        }
        
        function returnToHome() {
            document.getElementById('winMessage').style.display = 'none';
            document.getElementById('forcedCloseOverlay').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'none';
            document.getElementById('playerSelectionScreen').style.display = 'flex';
            document.getElementById('backButton').style.display = 'none';
            document.getElementById('closeButton').style.display = 'none';
            
            const bgMusic = document.getElementById('backgroundMusic');
            if (bgMusic && typeof bgMusic.pause === 'function') {
                 bgMusic.pause();
                 bgMusic.currentTime = 0;
            }
            updateProfileDisplay(); 
        }

        // --- Modified Game End and Exit Logic ---
        function gameEndLogic(winnerPlayerIndex, isForfeit = false, forfeitingPlayerIndex = -1) {
            gameActive = false;
            clearInterval(countdownInterval);
            
            const winner = players[winnerPlayerIndex];
            const humanPlayerObject = players.find(p => !p.isAI); // Assuming player 0 is human for stat tracking

            let winnings = selectedBetAmount * (playerCount -1);

            if (humanPlayerObject) {
                const humanIsWinner = (players.indexOf(humanPlayerObject) === winnerPlayerIndex);
                const humanForfeited = (isForfeit && players.indexOf(humanPlayerObject) === forfeitingPlayerIndex);

                if (humanIsWinner && !isForfeit) {
                    incrementWins();
                    addCoins(selectedBetAmount + winnings); // Own bet back + winnings
                } else if (humanForfeited || (!humanIsWinner && !isForfeit && players.includes(humanPlayerObject))) {
                    // If human forfeited, bet is already lost.
                    // If human lost in a normal game, bet is already lost.
                    // If human was playing and lost (not AI vs AI game)
                    incrementLosses();
                }
            }
            
            const overlayId = isForfeit ? 'forcedCloseOverlay' : 'winMessage';
            const titleEl = isForfeit ? document.getElementById('forcedCloseTitle') : document.getElementById('winnerText');
            const detailsEl = isForfeit ? document.getElementById('forcedCloseMessage') : document.getElementById('winDetails');

            if (isForfeit) {
                titleEl.textContent = `${players[forfeitingPlayerIndex].name} Left!`;
                detailsEl.textContent = winner ? `${winner.name} wins by default. Prize: ${winnings.toLocaleString()} coins.` : `Game abandoned.`;
                
                let timeLeft = 5;
                document.getElementById('forcedCloseTimer').textContent = timeLeft;
                const timerInterval = setInterval(() => {
                    timeLeft--;
                    document.getElementById('forcedCloseTimer').textContent = timeLeft;
                    if (timeLeft <= 0) {
                        clearInterval(timerInterval);
                        returnToHome();
                    }
                }, 1000);
            } else {
                titleEl.textContent = `${winner.name} Wins!`;
                titleEl.style.color = winner.color;
                detailsEl.textContent = `Congratulations! Prize: ${winnings.toLocaleString()} coins.`;
            }
            document.getElementById(overlayId).style.display = 'flex';

            playSound('winSound');
            const bgMusic = document.getElementById('backgroundMusic');
            if (bgMusic && typeof bgMusic.pause === 'function') bgMusic.pause();
        }

        function showExitConfirmation(actionType) {
            const dialog = document.getElementById('exitConfirmation');
            const title = document.getElementById('exitDialogTitle');
            const msg = document.getElementById('exitDialogMessage');
            const btn = document.getElementById('confirmExitButton');

            if (actionType === 'reset') {
                title.textContent = 'Reset Game';
                msg.textContent = 'This will forfeit the current game and your bet. Start a new game with the same settings?';
                btn.textContent = 'Yes, Reset';
                btn.onclick = confirmReset;
            } else { 
                title.textContent = 'Quit Game';
                msg.textContent = 'Are you sure? You will forfeit the game and your bet.';
                btn.textContent = 'Yes, Quit';
                btn.onclick = confirmQuitGame; 
            }
            dialog.style.display = 'flex';
        }
        function cancelExit() { document.getElementById('exitConfirmation').style.display = 'none';}

        function confirmQuitGame() {
            document.getElementById('exitConfirmation').style.display = 'none';
            if (!gameActive) { returnToHome(); return; } // Game not active, just go home

            const humanPlayerObject = players.find(p => !p.isAI);
            const humanPlayerIndex = humanPlayerObject ? players.indexOf(humanPlayerObject) : -1;
            
            let winner = null;
            if (playerCount > 1) {
                 winner = players.find(p => p !== humanPlayerObject) || players[ (players.indexOf(humanPlayerObject) +1 ) % playerCount]; // Simplified winner selection
            }
            gameEndLogic(players.indexOf(winner), true, humanPlayerIndex);
        }
        
        function confirmReset() { 
            document.getElementById('exitConfirmation').style.display = 'none';
            if (!gameActive) { initPlayerProfile(); return; } // Should not happen if called from game

            const humanPlayerObject = players.find(p => !p.isAI);
            if (humanPlayerObject) incrementLosses(); // Bet already lost

            if (playerCoins < selectedBetAmount) {
                alert(`Cannot reset. Not enough coins for new bet of ${selectedBetAmount.toLocaleString()}. Returning home.`);
                returnToHome();
                return;
            }
            deductCoins(selectedBetAmount); // Deduct for the new game instance.
            
            const currentPlayersCount = playerCount; 
            const bgMusic = document.getElementById('backgroundMusic');
            if (bgMusic && typeof bgMusic.pause === 'function') { bgMusic.pause(); bgMusic.currentTime = 0; }
            
            // Full Ludo game reset internals
            players = []; turnOrder = []; currentPlayerTurnIndex = 0; currentDiceValue = 0;
            humanPlayerCanMove = false; possibleMovesForHuman = []; extraTurnReason = null; gameActive = false;
            clearInterval(countdownInterval);

            startGameSetupInternal(currentPlayersCount); 
            document.getElementById('winMessage').style.display = 'none';
            document.getElementById('forcedCloseOverlay').style.display = 'none';
        }
        function resetGameConfirm() { showExitConfirmation('reset'); }


        // --- Board Layout Configuration ---
        function configureBoardLayout() {
            GRID_SIZE = 15; // Default
            MAIN_TRACK_LENGTH = 52;
            ACTIVE_MAIN_TRACK_COORDS = [...DEFAULT_MAIN_TRACK_COORDS_4P]; // Copy
            ACTIVE_SAFE_SQUARE_INDICES = [...DEFAULT_SAFE_SQUARE_INDICES_4P]; // Copy
            
            let tempGeomConfig = JSON.parse(JSON.stringify(DEFAULT_PLAYER_GEOMETRY_4P)); // Deep copy

            if (playerCount === 6) {
                // Simplified 6-player: add Purple and Orange to the 4-player config
                tempGeomConfig.push({ 
                    name:'Purple', homeArea: { x: 0.5, y: 6.5, w: 4, h: 4}, // Top-left diagonal area
                    startSquareGrid: [3, 6], startPosGlobal: 2, // Starts on Red's path
                    homePathEntryGlobalTrackPos: 0, // Enters home near its start
                    homePathSquaresGrid: [[5,7],[4,7],[3,7],[2,7],[1,7],[0.5,7.5]] // Diagonal path inward
                });
                tempGeomConfig.push({
                    name:'Orange', homeArea: { x: 10.5, y: 0.5, w: 4, h: 4}, // Top-right diagonal area
                    startSquareGrid: [8, 3], startPosGlobal: 15, // Starts on Green's path
                    homePathEntryGlobalTrackPos: 13,
                    homePathSquaresGrid: [[7,1],[7,2],[7,3],[7,4],[7,5],[7.5,0.5]] // Diagonal path inward
                });
                ACTIVE_PLAYER_GEOMETRY_CONFIG = tempGeomConfig.slice(0, 6);
            } else if (playerCount === 3) { // Red, Green, Yellow
                 ACTIVE_PLAYER_GEOMETRY_CONFIG = [tempGeomConfig[0], tempGeomConfig[1], tempGeomConfig[2]];
            } else if (playerCount === 2) { // Red, Yellow (opposite)
                ACTIVE_PLAYER_GEOMETRY_CONFIG = [tempGeomConfig[0], tempGeomConfig[2]];
            } else { // 4 players
                ACTIVE_PLAYER_GEOMETRY_CONFIG = tempGeomConfig.slice(0, 4);
            }
            CELL_SIZE = canvasEl.width / GRID_SIZE;
            TOKEN_RADIUS = CELL_SIZE * 0.30; // Slightly smaller tokens for potentially crowded board
        }

        // --- Ludo Game Initialization ---
        function startGameSetupInternal(countFromSelection) { // Renamed to avoid conflict
            playerCount = countFromSelection;
            configureBoardLayout(); 

            document.getElementById('playerSelectionScreen').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'flex';
            
            setupTurnOrderInputs(); 
            initLudoGameCore(); 
            
            const bgMusic = document.getElementById('backgroundMusic');
            if (document.getElementById('soundEffects').checked && bgMusic && typeof bgMusic.play === 'function') {
                bgMusic.volume = 0.15;
                bgMusic.play().catch(e => console.warn("Autoplay music error:", e));
            }
        }
        
        function initLudoGameCore() { 
            players = [];
            for (let i = 0; i < playerCount; i++) {
                const playerColorInfo = baseColors[i]; // R, G, Y, B, P, O order
                const geometry = ACTIVE_PLAYER_GEOMETRY_CONFIG[i];
                
                if (!geometry) { console.error(`No geometry for player ${i}`); continue; }

                players.push({
                    name: playerColorInfo.name, // Use name from baseColors for consistency
                    color: playerColorInfo.code,
                    isAI: false, 
                    geometry: geometry, // This now directly comes from ACTIVE_PLAYER_GEOMETRY_CONFIG
                    tokens: Array(TOKENS_PER_PLAYER).fill(null).map((_, k) => ({
                        id: k, state: 'home', position: -1, globalTrackPos: -1, displayPos: { x: 0, y: 0 }
                    })),
                    finishedTokens: 0
                });
            }
            
            updateTurnOrder(); 
            currentDiceValue = 0;
            gameActive = true;
            humanPlayerCanMove = false;
            possibleMovesForHuman = [];
            extraTurnReason = null;

            const aiVsAi = document.getElementById('aiVsAi').checked;
            const autoMode = document.getElementById('autoMode').checked;
            players.forEach((p, idx) => {
                if (aiVsAi) p.isAI = true;
                else p.isAI = idx > 0 && autoMode; // Player 0 (Red) is human unless AiVsAi
            });
             if (playerCount === 1 && players[0]) players[0].isAI = false;


            updateCurrentPlayerDisplay();
            updateTokenBalances();
            drawBoard(); // Initial draw
            
            const firstPlayer = players[turnOrder[currentPlayerTurnIndex]];
            if (firstPlayer) {
                showGameMessage(`${firstPlayer.name}'s turn. Roll dice.`);
                if (firstPlayer.isAI && document.getElementById('autoRoll').checked) {
                    startCountdown(handleDiceRollAction);
                }
            } else {
                showGameMessage("Error: No first player. Please reset.");
            }
            
            // Ensure event listeners are correctly set up or re-attached if necessary
            document.getElementById('dice').removeEventListener('click', handleDiceRollAction); // Remove old if any
            document.getElementById('dice').addEventListener('click', handleDiceRollAction);
            canvasEl.removeEventListener('click', handleCanvasClick); // Remove old if any
            canvasEl.addEventListener('click', handleCanvasClick);
            
            document.getElementById('backButton').style.display = 'block';
            document.getElementById('closeButton').style.display = 'block';
            document.getElementById('backButton').onclick = () => showExitConfirmation('exit');
            document.getElementById('closeButton').onclick = () => showExitConfirmation('exit');
        }

        // --- All other Ludo game logic functions (drawBoard, getPossibleMoves, executeMove, AI, etc.) ---
        // These functions should now use `ACTIVE_MAIN_TRACK_COORDS`, `ACTIVE_SAFE_SQUARE_INDICES`,
        // and `player.geometry` from `ACTIVE_PLAYER_GEOMETRY_CONFIG`.
        // The `endGame` call within `executeMove` should be `gameEndLogic(playerIndex)`.
        // (Copying the full Ludo logic here, adapted as described)

        function drawBoard() {
            ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--board-bg').trim();
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            ACTIVE_PLAYER_GEOMETRY_CONFIG.forEach((geom, geomIndex) => {
                if (geomIndex >= playerCount) return; 
                let displayColor = players[geomIndex]?.color || baseColors[geomIndex]?.code || 'grey';

                ctx.fillStyle = displayColor.replace(')', ', 0.3)').replace('var(', 'rgba('); 
                ctx.fillRect(geom.homeArea.x * CELL_SIZE, geom.homeArea.y * CELL_SIZE, geom.homeArea.w * CELL_SIZE, geom.homeArea.h * CELL_SIZE);
                ctx.strokeStyle = displayColor; ctx.lineWidth = 2;
                ctx.strokeRect(geom.homeArea.x * CELL_SIZE, geom.homeArea.y * CELL_SIZE, geom.homeArea.w * CELL_SIZE, geom.homeArea.h * CELL_SIZE);
                
                geom.homePathSquaresGrid.forEach((sq) => {
                    ctx.fillStyle = displayColor.replace(')', ', 0.5)').replace('var(', 'rgba(');
                    ctx.fillRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    ctx.strokeStyle = displayColor;
                    ctx.strokeRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                });
            });

            ACTIVE_MAIN_TRACK_COORDS.forEach((sq, index) => {
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim();
                ctx.lineWidth = 1;
                ctx.strokeRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                
                ACTIVE_PLAYER_GEOMETRY_CONFIG.forEach((geom, geomIndex) => {
                    if (geomIndex >= playerCount) return;
                    if (geom.startPosGlobal === index) {
                        let playerForGeom = players[geomIndex];
                        if (playerForGeom) {
                            ctx.fillStyle = playerForGeom.color.replace(')', ', 0.3)').replace('var(', 'rgba(');
                            ctx.fillRect(sq[0] * CELL_SIZE, sq[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        }
                    }
                });

                if (ACTIVE_SAFE_SQUARE_INDICES.includes(index)) {
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--safe-star-color').trim();
                    ctx.font = `${CELL_SIZE * 0.6}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText('★', (sq[0] + 0.5) * CELL_SIZE, (sq[1] + 0.5) * CELL_SIZE);
                }
            });
            
            const mid = Math.floor(GRID_SIZE / 2);
            ctx.beginPath();
            ctx.moveTo((mid -1) * CELL_SIZE, mid * CELL_SIZE); ctx.lineTo(mid * CELL_SIZE, (mid-1) * CELL_SIZE);
            ctx.lineTo((mid +1) * CELL_SIZE, mid * CELL_SIZE); ctx.lineTo(mid * CELL_SIZE, (mid+1) * CELL_SIZE);
            ctx.closePath(); ctx.fillStyle = '#bbb'; ctx.fill();
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim();
            ctx.stroke();

            players.forEach((player, playerIdx) => {
                if (!player || !player.tokens) return;
                const geom = player.geometry;
                player.tokens.forEach((token, tokenIdx) => {
                    let x, y;
                    if (token.state === 'home') {
                        const homeW = geom.homeArea.w; const homeH = geom.homeArea.h;
                        const relX = (tokenIdx % 2 === 0) ? homeW * 0.25 : homeW * 0.75;
                        const relY = (tokenIdx < 2) ? homeH * 0.25 : homeH * 0.75;
                        x = (geom.homeArea.x + relX) * CELL_SIZE; y = (geom.homeArea.y + relY) * CELL_SIZE;
                    } else if (token.state === 'track') {
                        const globalPos = token.globalTrackPos;
                        if (globalPos !== -1 && globalPos < ACTIVE_MAIN_TRACK_COORDS.length) {
                            const sq = ACTIVE_MAIN_TRACK_COORDS[globalPos];
                            x = (sq[0] + 0.5) * CELL_SIZE; y = (sq[1] + 0.5) * CELL_SIZE;
                        } else { return; }
                    } else if (token.state === 'homestretch') {
                        if(token.position >= 0 && token.position < geom.homePathSquaresGrid.length) {
                            const sq = geom.homePathSquaresGrid[token.position];
                            x = (sq[0] + 0.5) * CELL_SIZE; y = (sq[1] + 0.5) * CELL_SIZE;
                        } else { return; }
                    } else { // finished
                        const finalHomeSqIdx = Math.min(HOME_STRETCH_LENGTH -1, geom.homePathSquaresGrid.length -1);
                        const finalHomeSq = geom.homePathSquaresGrid[finalHomeSqIdx];
                        x = (finalHomeSq[0] + 0.5 + (tokenIdx - 1.5) * 0.05 * GRID_SIZE/15) * CELL_SIZE; // Spread them out a bit
                        y = (finalHomeSq[1] + 0.5) * CELL_SIZE;
                    }
                    token.displayPos = {x, y};
                    drawToken(x, y, player.color, token, playerIdx);
                });
            });
        }

        function getPossibleMoves(playerIndex, diceRoll) {
            const player = players[playerIndex];
            const moves = [];
            if (!player || !player.tokens || !player.geometry) return moves;

            player.tokens.forEach((token, tokenIdx) => {
                if (token.state === 'finished') return;

                if (token.state === 'home') {
                    if (diceRoll === 6) {
                        const startGlobalPos = player.geometry.startPosGlobal;
                        let ownTokensOnStart = 0;
                        player.tokens.forEach(t => {
                            if (t.state === 'track' && t.globalTrackPos === startGlobalPos) ownTokensOnStart++;
                        });
                        if (ownTokensOnStart < 2) { 
                             moves.push({ tokenIndex: tokenIdx, fromState: 'home', toState: 'track', newPosition: 0, newGlobalTrackPos: player.geometry.startPosGlobal });
                        }
                    }
                } else if (token.state === 'track') {
                    const currentTrackProgress = token.position; 
                    const newTrackProgress = currentTrackProgress + diceRoll;
                    
                    // Calculate how many steps on the main track this player needs to take before entering their home path.
                    // This is (their home entry point - their start point) modulo MAIN_TRACK_LENGTH.
                    let stepsToHomeEntrySquare;
                    if (player.geometry.homePathEntryGlobalTrackPos >= player.geometry.startPosGlobal) {
                        stepsToHomeEntrySquare = player.geometry.homePathEntryGlobalTrackPos - player.geometry.startPosGlobal;
                    } else { // Wraps around
                        stepsToHomeEntrySquare = MAIN_TRACK_LENGTH - player.geometry.startPosGlobal + player.geometry.homePathEntryGlobalTrackPos;
                    }

                    if (newTrackProgress <= stepsToHomeEntrySquare) { // Stays on main track before or at home entry point
                        const newGlobalPos = (player.geometry.startPosGlobal + newTrackProgress) % MAIN_TRACK_LENGTH;
                        moves.push({ tokenIndex: tokenIdx, fromState: 'track', toState: 'track', newPosition: newTrackProgress, newGlobalTrackPos: newGlobalPos });
                    } else { // Moving into home stretch
                        const stepsIntoHomeStretch = newTrackProgress - (stepsToHomeEntrySquare + 1);
                        if (stepsIntoHomeStretch < HOME_STRETCH_LENGTH -1) { // Moves within home stretch squares 0-4
                            moves.push({ tokenIndex: tokenIdx, fromState: 'track', toState: 'homestretch', newPosition: stepsIntoHomeStretch, newGlobalTrackPos: -1 });
                        } else if (stepsIntoHomeStretch === HOME_STRETCH_LENGTH -1 ) { // Lands on final home spot (index 5 of home stretch)
                            moves.push({ tokenIndex: tokenIdx, fromState: 'track', toState: 'finished', newPosition: 0, newGlobalTrackPos: -1 }); // newPosition for finished is irrelevant
                        }
                        // If stepsIntoHomeStretch > HOME_STRETCH_LENGTH -1 (overshot), it's an invalid move from track into home.
                    }
                } else if (token.state === 'homestretch') {
                    const newHomePos = token.position + diceRoll;
                    if (newHomePos < HOME_STRETCH_LENGTH -1) { 
                        moves.push({ tokenIndex: tokenIdx, fromState: 'homestretch', toState: 'homestretch', newPosition: newHomePos, newGlobalTrackPos: -1 });
                    } else if (newHomePos === HOME_STRETCH_LENGTH -1) { 
                        moves.push({ tokenIndex: tokenIdx, fromState: 'homestretch', toState: 'finished', newPosition: 0, newGlobalTrackPos: -1 });
                    }
                }
            });
            return moves;
        }
        
        // --- Other Ludo functions (executeMove, AI, UI updates, etc.) copied and adapted ---
        // (Ensure all these functions are present from your previous complete Ludo script,
        // calling gameEndLogic where appropriate, and using ACTIVE_ board constants)
        function executeMove(playerIndex, chosenMove) {
            humanPlayerCanMove = false; 
            const player = players[playerIndex];
            const token = player.tokens[chosenMove.tokenIndex];

            token.state = chosenMove.toState;
            token.position = chosenMove.newPosition;
            token.globalTrackPos = chosenMove.newGlobalTrackPos !== undefined ? chosenMove.newGlobalTrackPos : -1;
            
            playSound('moveSound');
            let message = `${player.name} moved a token.`;

            if (token.state === 'track' && !isSafePosition(token.globalTrackPos)) {
                for (let i = 0; i < playerCount; i++) {
                    if (i === playerIndex || !players[i]) continue; 
                    const opponent = players[i];
                    opponent.tokens.forEach(opToken => {
                        if (opToken.state === 'track' && opToken.globalTrackPos === token.globalTrackPos) {
                            opToken.state = 'home'; opToken.position = -1; opToken.globalTrackPos = -1;
                            message = `${player.name} captured ${opponent.name}'s token!`;
                            playSound('captureSound'); extraTurnReason = 'capture'; 
                        }
                    });
                }
            }

            if (token.state === 'finished') {
                player.finishedTokens++;
                message = `${player.name}'s token reached home!`;
                if (player.finishedTokens === TOKENS_PER_PLAYER) {
                    gameEndLogic(playerIndex); // Use the new game end logic
                    return; 
                }
                if (currentDiceValue === 6 && extraTurnReason === 'dice_6') {
                    extraTurnReason = 'home_entry_6_no_extra'; 
                }
            }
            
            if (extraTurnReason === 'home_entry_6_no_extra') extraTurnReason = null;
            showGameMessage(message); updateTokenBalances(); drawBoard();
            setTimeout(nextTurn, 1000); 
        }
        function isSafePosition(globalTrackPos) { return ACTIVE_SAFE_SQUARE_INDICES.includes(globalTrackPos); }
        function nextTurn() {
            humanPlayerCanMove = false; possibleMovesForHuman = []; currentDiceValue = 0; 
            document.getElementById('diceValue').textContent = `Dice: -`;

            const currentPlayerObj = players[turnOrder[currentPlayerTurnIndex]];

            if (extraTurnReason && currentPlayerObj) { 
                showGameMessage(`${currentPlayerObj.name} gets an extra turn (${extraTurnReason.replace(/_/g, ' ')})! Roll dice.`);
                extraTurnReason = null; 
            } else {
                currentPlayerTurnIndex = (currentPlayerTurnIndex + 1) % playerCount;
                updateCurrentPlayerDisplay();
                if (players[turnOrder[currentPlayerTurnIndex]]) { // Check if next player exists
                    showGameMessage(`${players[turnOrder[currentPlayerTurnIndex]].name}'s turn. Roll dice.`);
                }
            }
            
            const nextPlayer = players[turnOrder[currentPlayerTurnIndex]];
            if (nextPlayer && nextPlayer.isAI && document.getElementById('autoRoll').checked) {
                startCountdown(handleDiceRollAction);
            }
            drawBoard(); 
        }
        function updateCurrentPlayerDisplay() {
            if (!players || players.length === 0 || !players[turnOrder[currentPlayerTurnIndex]] || turnOrder.length === 0) {
                // console.warn("Cannot update current player display, players/turnOrder not ready.");
                document.getElementById('currentPlayer').textContent = "Loading...";
                return;
            }
            const player = players[turnOrder[currentPlayerTurnIndex]];
            const display = document.getElementById('currentPlayer');
            display.textContent = `Current Player: ${player.name}`;
            display.style.color = player.color;
        }
        function showGameMessage(message) { document.getElementById('gameMessage').textContent = message; }
        function updateTokenBalances() {
            const container = document.getElementById('tokenBalances'); container.innerHTML = '';
            players.forEach(player => {
                if(!player) return;
                const balanceElement = document.createElement('div');
                balanceElement.className = 'token-balance';
                balanceElement.style.background = player.color;
                const tokensLeft = TOKENS_PER_PLAYER - player.finishedTokens;
                balanceElement.textContent = `${player.name}: ${tokensLeft}`;
                container.appendChild(balanceElement);
            });
        }
         function handleCanvasClick(event) {
            if (!humanPlayerCanMove || !gameActive) return;
            const rect = canvasEl.getBoundingClientRect();
            const clickX = event.clientX - rect.left; const clickY = event.clientY - rect.top;
            const playerIndex = turnOrder[currentPlayerTurnIndex];
            const player = players[playerIndex];

            for (const move of possibleMovesForHuman) {
                const token = player.tokens[move.tokenIndex];
                if (!token.displayPos) continue; 
                const dx = clickX - token.displayPos.x; const dy = clickY - token.displayPos.y;
                if (dx * dx + dy * dy < TOKEN_RADIUS * TOKEN_RADIUS * 1.8 * 1.8) { // Increased click area slightly more
                    executeMove(playerIndex, move); humanPlayerCanMove = false; 
                    possibleMovesForHuman = []; drawBoard(); return;
                }
            }
        }
        function startCountdown(callback) {
            clearInterval(countdownInterval); const bar = document.getElementById('countdownBar');
            if (!bar) return; // Element might not be visible if game screen isn't up
            bar.style.width = '100%'; let timeLeft = 100; 
            countdownInterval = setInterval(() => {
                timeLeft -= 5; bar.style.width = `${Math.max(0, timeLeft)}%`;
                if (timeLeft <= 0) { clearInterval(countdownInterval); if (gameActive) callback(); }
            }, 100); 
        }
        function playSound(soundId) {
            const soundEnabled = document.getElementById('soundEffects')?.checked;
            if (soundEnabled) {
                const sound = document.getElementById(soundId);
                if (sound && typeof sound.play === 'function') {
                    sound.currentTime = 0;
                    sound.play().catch(e => console.warn(`Sound ${soundId} play error:`, e));
                }
            }
        }
        function aiMakeMove(playerIndex, possibleMoves) { 
            const player = players[playerIndex];
            let bestMove = null;

            if (currentDiceValue === 6) {
                const homeTokenMove = possibleMoves.find(m => m.fromState === 'home');
                if (homeTokenMove) {
                    const tokensOnBoard = player.tokens.filter(t => t.state === 'track' || t.state === 'homestretch').length;
                    if (tokensOnBoard < TOKENS_PER_PLAYER / 2 || Math.random() < 0.6) bestMove = homeTokenMove; // More likely to get out if few tokens
                }
            }
            
            if (!bestMove && document.getElementById('smartCapture').checked) {
                const captureMoves = [];
                for (const move of possibleMoves) {
                    if (move.toState === 'track' && !isSafePosition(move.newGlobalTrackPos)) {
                        for (let i = 0; i < playerCount; i++) {
                            if (i === playerIndex || !players[i]) continue;
                            if (players[i].tokens.some(opToken => opToken.state === 'track' && opToken.globalTrackPos === move.newGlobalTrackPos)) {
                                captureMoves.push(move); break;
                            }
                        }
                    }
                }
                if(captureMoves.length > 0) bestMove = captureMoves[Math.floor(Math.random() * captureMoves.length)]; // Pick one randomly if multiple captures
            }

            if (!bestMove) {
                const finishingMoves = possibleMoves.filter(m => m.toState === 'finished');
                if (finishingMoves.length > 0) bestMove = finishingMoves[0]; // Prioritize any finishing move
            }

            if (!bestMove && document.getElementById('safeMove').checked) {
                const safeMoves = possibleMoves.filter(m => m.toState === 'track' && isSafePosition(m.newGlobalTrackPos));
                if (safeMoves.length > 0) {
                    safeMoves.sort((a,b) => players[playerIndex].tokens[b.tokenIndex].position - players[playerIndex].tokens[a.tokenIndex].position); // Prefer advancing furthest
                    bestMove = safeMoves[0];
                }
            }
            
            if (!bestMove) { // General advancement
                let candidateMoves = possibleMoves.filter(m => m.fromState !== 'home' || currentDiceValue === 6); // Don't just move out unless it's a 6 or no other choice
                if (candidateMoves.length === 0) candidateMoves = possibleMoves; 

                candidateMoves.sort((a, b) => { // Complex sort: home stretch > furthest on track > home exit
                    const tokenA = player.tokens[a.tokenIndex]; const tokenB = player.tokens[b.tokenIndex];
                    const scoreA = (a.toState === 'homestretch' ? 200 : (tokenA.state === 'track' ? 100 : 0)) + tokenA.position;
                    const scoreB = (b.toState === 'homestretch' ? 200 : (tokenB.state === 'track' ? 100 : 0)) + tokenB.position;
                    return scoreB - scoreA;
                });
                if (candidateMoves.length > 0) bestMove = candidateMoves[0];
            }

            if (!bestMove && possibleMoves.length > 0) { // Absolute fallback
                bestMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
            }
            
            if (bestMove) {
                 setTimeout(() => { if(gameActive) executeMove(playerIndex, bestMove); }, 300 + Math.random()*500); // Add slight delay for AI "thinking"
            } else { 
                console.warn("AI had no moves but aiMakeMove was called or couldn't pick.");
                if(gameActive) nextTurn();
            }
        }
         function setupTurnOrderInputs() {
            const container = document.getElementById('customTurnOrderContainer');
            const button = container.querySelector('button'); // Keep the button
            container.innerHTML = '<label>Turn Order:</label>'; // Clear old inputs, keep label
            if (button) container.appendChild(button); // Add button back

            for (let i = 0; i < playerCount; i++) {
                const input = document.createElement('input');
                input.type = 'text'; input.id = `turn${baseColors[i].name}`;
                input.placeholder = (i + 1).toString(); input.value = (i + 1).toString();
                input.style.borderColor = baseColors[i].code; 
                if(button) container.insertBefore(input, button); 
                else container.appendChild(input);
            }
        }
        function updateTurnOrder() {
            const newOrderPreferences = [];
            for (let i = 0; i < playerCount; i++) {
                const input = document.getElementById(`turn${baseColors[i].name}`);
                const orderVal = parseInt(input?.value) || (i + 1); 
                newOrderPreferences.push({ playerIndex: i, order: orderVal });
            }
            newOrderPreferences.sort((a, b) => a.order - b.order);
            turnOrder = newOrderPreferences.map(item => item.playerIndex);
            currentPlayerTurnIndex = 0; 
            updateCurrentPlayerDisplay();
            const firstPlayer = players[turnOrder[currentPlayerTurnIndex]];
            if (firstPlayer) { 
                 showGameMessage(`Turn order updated. ${firstPlayer.name}'s turn.`);
                 if (gameActive && firstPlayer.isAI && document.getElementById('autoRoll').checked) {
                     startCountdown(handleDiceRollAction);
                 }
            }
        }
         function handleDiceRollAction() {
            if (!gameActive || humanPlayerCanMove) return; 
            if (!players || players.length === 0 || turnOrder.length === 0 || !players[turnOrder[currentPlayerTurnIndex]]) return;
            const player = players[turnOrder[currentPlayerTurnIndex]];
            // Player 0 is human if autoMode is unchecked OR aiVsAi is unchecked.
            const player0IsHuman = (!document.getElementById('autoMode').checked && turnOrder[currentPlayerTurnIndex] === 0 && !document.getElementById('aiVsAi').checked) ||
                                   (turnOrder[currentPlayerTurnIndex] === 0 && !document.getElementById('aiVsAi').checked && !player.isAI);


            if (player.isAI || player0IsHuman) { 
                 rollDice();
            } else if (!player.isAI && turnOrder[currentPlayerTurnIndex] !== 0 && !document.getElementById('autoMode').checked) {
                // This case is for human player (not player 0) when automode is OFF.
                rollDice();
            }
        }
         function rollDice() {
            if (!gameActive) return;
            const diceElement = document.getElementById('dice');
            diceElement.classList.add('animate'); playSound('diceSound');
            setTimeout(() => {
                if (!gameActive) return; // Check again in case game ended during animation
                currentDiceValue = Math.floor(Math.random() * 6) + 1;
                diceElement.textContent = getDiceFace(currentDiceValue);
                diceElement.classList.remove('animate');
                document.getElementById('diceValue').textContent = `Dice: ${currentDiceValue}`;
                extraTurnReason = (currentDiceValue === 6) ? 'dice_6' : null;
                processPlayerTurn();
            }, 500);
        }
         function processPlayerTurn() {
            if (!gameActive || !players || players.length === 0 || turnOrder.length === 0 || !players[turnOrder[currentPlayerTurnIndex]]) return;
            const playerIndex = turnOrder[currentPlayerTurnIndex];
            const player = players[playerIndex];
            possibleMovesForHuman = getPossibleMoves(playerIndex, currentDiceValue);

            if (possibleMovesForHuman.length === 0) {
                showGameMessage(`${player.name} rolled ${currentDiceValue}. No moves available.`);
                playSound('errorSound'); setTimeout(() => { if(gameActive) nextTurn(); }, 1500);
            } else {
                if (player.isAI) {
                    showGameMessage(`${player.name} (AI) rolled ${currentDiceValue}. Thinking...`);
                    // AI move is now delayed within aiMakeMove itself
                    aiMakeMove(playerIndex, possibleMovesForHuman);
                } else { 
                    humanPlayerCanMove = true;
                    showGameMessage(`${player.name}, select a token to move ${currentDiceValue}.`);
                    drawBoard(); 
                }
            }
        }
        function getDiceFace(value) { const faces = ['⚀', '⚁', '⚂', '⚃', '⚄', '⚅']; return faces[value - 1]; }
        function drawToken(x, y, color, tokenData, playerIndexOfTokenOwner) { 
            ctx.beginPath(); ctx.arc(x, y, TOKEN_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = color; ctx.fill();
            ctx.strokeStyle = '#333'; ctx.lineWidth = 1; ctx.stroke(); // Thinner border for tokens

            if (players.length === 0 || turnOrder.length === 0) return; 
            const currentPlayerRealIndex = turnOrder[currentPlayerTurnIndex];
            if (humanPlayerCanMove && playerIndexOfTokenOwner === currentPlayerRealIndex) {
                const isMovable = possibleMovesForHuman.some(move => move.tokenIndex === tokenData.id);
                if (isMovable) {
                    ctx.strokeStyle = 'gold'; ctx.lineWidth = 2.5; ctx.stroke();
                }
            }
        }
        
        // --- Main Script Initialization ---
        window.onload = () => {
            initPlayerProfile();
        };
    </script>
</body>
</html>
